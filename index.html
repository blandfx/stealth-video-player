<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IMG-Only Video Player</title>
  <link rel="icon" type="image/png" href="./favicon.png?v=1">
  <style>
    :root {
      --bg: #0d0f13;
      --panel: #171b22;
      --text: #edf0f4;
      --muted: #9ea6b2;
      --line: #2b313d;
      --accent: #5da8ff;
      --overlay-icon-size: 32px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 17px;
      background: radial-gradient(circle at top, #1a2030 0%, var(--bg) 55%);
      color: var(--text);
      display: grid;
      place-items: center;
      padding: 20px;
    }

    .app {
      width: 95%;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 16px;
    }

    body.full-width {
      display: block;
      padding: 0;
      overflow: hidden;
    }

    body.full-width .app {
      width: 100%;
      max-width: none;
      height: 100vh;
      min-height: 100vh;
      border-radius: 0;
      border: 0;
      padding: 0;
    }

    form {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 10px;
      margin-bottom: 14px;
    }

    .url-source {
      margin: -4px 0 12px;
      color: #8ec5ff;
      font-size: 0.85rem;
      display: none;
    }

    input {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: #0f131a;
      color: var(--text);
      outline: none;
    }

    input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(93, 168, 255, 0.25);
    }

    button {
      border: 1px solid #3f77ad;
      background: #2f5f90;
      color: #fff;
      border-radius: 8px;
      padding: 0 14px;
      cursor: pointer;
    }

    .video-settings {
      margin-bottom: 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
      background: linear-gradient(180deg, #121824 0%, #101620 100%);
      display: grid;
      gap: 10px;
    }

    .video-settings-head {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
    }

    .video-settings-head-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .video-settings-title {
      margin: 0;
      font-size: 0.95rem;
      letter-spacing: 0.02em;
      color: #deebff;
    }

    .video-settings-subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.8rem;
    }

    .video-settings-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: 1fr;
    }

    .setting-card {
      border: 1px solid #273448;
      border-radius: 10px;
      background: #0f1520;
      padding: 10px;
      display: grid;
      gap: 8px;
      min-height: 86px;
    }

    .setting-card[hidden] {
      display: none !important;
    }

    .setting-label {
      color: #cbd7e7;
      font-size: 0.84rem;
      letter-spacing: 0.01em;
    }

    .renderer-options {
      display: grid;
      gap: 8px;
    }

    .renderer-radio {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .renderer-option {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 10px;
      align-items: center;
      border: 1px solid #2d3e56;
      border-radius: 9px;
      background: #101a28;
      padding: 9px 10px;
      cursor: pointer;
      transition: border-color 120ms ease, background 120ms ease;
    }

    .renderer-option::before {
      content: "";
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid #70819a;
      box-sizing: border-box;
      box-shadow: inset 0 0 0 0 #6cb0ff;
      transition: border-color 120ms ease, box-shadow 120ms ease;
    }

    .renderer-option-text {
      display: grid;
      gap: 2px;
      min-width: 0;
    }

    .renderer-option-title {
      color: #deebff;
      font-size: 0.89rem;
      font-weight: 700;
      line-height: 1.15;
    }

    .renderer-option-subtitle {
      color: #97aac1;
      font-size: 0.74rem;
      line-height: 1.2;
    }

    .renderer-radio:checked + .renderer-option {
      border-color: #5f9be0;
      background: #13243a;
    }

    .renderer-radio:checked + .renderer-option::before {
      border-color: #77bcff;
      box-shadow: inset 0 0 0 3px #77bcff;
    }

    .renderer-radio:focus-visible + .renderer-option {
      outline: 2px solid rgba(119, 188, 255, 0.5);
      outline-offset: 1px;
    }

    .quality-block {
      display: grid;
      gap: 8px;
    }

    .quality-slider-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
    }

    #qualityInput {
      width: 100%;
      padding: 0;
      accent-color: #77bcff;
    }

    .quality-note {
      color: var(--muted);
      font-size: 0.8rem;
      line-height: 1.3;
    }

    #qualityValue {
      min-width: 34px;
      text-align: center;
      color: #dbeaff;
      background: #1a2537;
      border: 1px solid #32445e;
      border-radius: 7px;
      padding: 5px 6px;
      font-size: 0.82rem;
      line-height: 1;
    }

    #applyVideoSettingsBtn {
      min-height: 40px;
      justify-self: end;
      padding: 0 16px;
      font-weight: 700;
    }

    .video-settings-actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    #videoSettingsToggleBtn {
      min-height: 34px;
      padding: 0 12px;
      font-weight: 700;
      border-color: #415b79;
      background: #22364f;
    }

    .bandwidth-monitor {
      color: #d6e6ff;
      border: 1px solid #32445e;
      border-radius: 8px;
      background: #121c2a;
      padding: 8px 10px;
      font-size: 0.82rem;
      line-height: 1.2;
      min-width: 170px;
    }

    .status-row {
      margin-top: 15px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 10px;
    }

    .status-chip {
      color: #d6e6ff;
      border: 1px solid #32445e;
      border-radius: 8px;
      background: #121c2a;
      padding: 8px 10px;
      font-size: 0.82rem;
      line-height: 1.2;
      flex: 1 1 170px;
      max-width: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .channels-modal {
      position: fixed;
      inset: 0;
      background: rgba(6, 9, 14, 0.72);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 14px;
    }

    .channels-modal.show {
      display: flex;
    }

    .channels-panel {
      width: min(820px, 100%);
      max-height: 85vh;
      background: #101620;
      border: 1px solid #2e3745;
      border-radius: 12px;
      display: grid;
      grid-template-rows: auto auto minmax(0, 1fr);
      overflow: hidden;
    }

    .channels-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid #2e3745;
    }

    .channels-head h3 {
      margin: 0;
      font-size: 0.96rem;
      color: #deebff;
    }

    .channels-search {
      padding: 10px 12px;
      border-bottom: 1px solid #2e3745;
    }

    #channelsSearch {
      width: 100%;
      padding: 10px;
    }

    #channelsList {
      overflow: auto;
      padding: 8px;
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fill, minmax(100px, 100px));
      justify-content: start;
    }

    .channel-item {
      width: 100px;
      height: 100px;
      border: 1px solid #334258;
      background: #132033;
      border-radius: 8px;
      padding: 8px;
      text-align: center;
      color: #edf0f4;
      cursor: pointer;
      display: grid;
      align-items: center;
      justify-items: center;
    }

    .channel-item:hover {
      border-color: #67adff;
      background: #1a2f49;
    }

    .channel-logo {
      width: 84px;
      height: 84px;
      object-fit: contain;
      display: block;
    }

    .channel-logo-fallback {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      font-size: 0.9rem;
      color: #9ea6b2;
      border: 1px dashed #3b4b63;
      border-radius: 6px;
      padding: 6px;
    }

    #bandwidthMonitor {
      text-align: right;
      margin-left: auto;
    }

    #syncInfo {
      margin: 0;
    }

    .plex-history {
      margin-top: 14px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #101722;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .plex-history-title {
      margin: 0;
      font-size: 0.95rem;
      color: #deebff;
      letter-spacing: 0.01em;
    }

    .plex-history-list {
      display: grid;
      gap: 6px;
    }

    .plex-history-item {
      width: 100%;
      text-align: left;
      border: 1px solid #334258;
      background: #132033;
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      cursor: pointer;
    }

    .plex-history-item:hover {
      border-color: #67adff;
      background: #1a2f49;
    }

    .plex-history-name {
      font-size: 0.9rem;
      font-weight: 600;
    }

    .plex-history-main {
      min-width: 0;
      display: grid;
      gap: 3px;
      flex: 1 1 auto;
    }

    .plex-history-meta {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .plex-history-remove {
      width: 48px;
      height: 48px;
      border-radius: 10px;
      border: 1px solid #5c6a82;
      background: #1c2a3d;
      color: #f3f7ff;
      font-size: 1.35rem;
      font-weight: 800;
      line-height: 1;
      display: grid;
      place-items: center;
      cursor: pointer;
      flex: 0 0 auto;
      touch-action: manipulation;
    }

    .plex-history-remove:hover {
      border-color: #ff8a8a;
      background: #472832;
    }

    .plex-history-empty {
      color: var(--muted);
      font-size: 0.85rem;
      padding: 4px 0;
    }

    .video-settings.collapsed .video-settings-grid,
    .video-settings.collapsed .video-settings-actions {
      display: none;
    }

    .controls {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .offset-nudges {
      display: flex;
      gap: 10px;
      width: 100%;
      align-items: center;
    }

    .offset-btn {
      flex: 1 1 240px;
      min-height: 56px;
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      touch-action: manipulation;
    }

    .offset-value {
      min-width: 110px;
      text-align: center;
      font-size: 1.05rem;
      font-weight: 700;
      color: #d8e8ff;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 12px 10px;
      background: #111a28;
    }

    .plex {
      margin-bottom: 12px;
      position: relative;
    }

    #plexSearch {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: #0f131a;
      color: var(--text);
      outline: none;
    }

    #plexSuggest {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      right: 0;
      background: #0d1118;
      border: 1px solid var(--line);
      border-radius: 8px;
      max-height: 520px;
      overflow-y: auto;
      z-index: 50;
      display: none;
    }

    .plex-item {
      width: 100%;
      text-align: left;
      border: 0;
      border-bottom: 1px solid #1f2631;
      border-radius: 0;
      background: transparent;
      color: var(--text);
      padding: 18px 16px;
      min-height: 72px;
      font-size: 1.12rem;
      line-height: 1.2;
      cursor: pointer;
    }

    .plex-item:last-child {
      border-bottom: 0;
    }

    .plex-item small {
      color: var(--muted);
      margin-left: 10px;
      font-size: 0.98rem;
    }

    #plexBrowser {
      margin-top: 8px;
      border: 1px solid var(--line);
      border-radius: 8px;
      background: #0d1118;
      max-height: 520px;
      overflow-y: auto;
      display: none;
    }

    .plex-header {
      padding: 8px 10px;
      color: var(--muted);
      font-size: 0.85rem;
      border-bottom: 1px solid #1f2631;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .plex-back {
      border: 1px solid #3d4a5c;
      border-radius: 6px;
      padding: 4px 8px;
      background: #172030;
      color: #fff;
    }

    .screen {
      width: 100%;
      aspect-ratio: 16 / 9;
      border: 1px solid var(--line);
      border-radius: 10px;
      overflow: hidden;
      background: #05070a;
      display: grid;
      place-items: center;
      position: relative;
      cursor: default;
    }

    body.full-width .screen {
      width: 100vw;
      height: 100vh;
      aspect-ratio: auto;
      border-radius: 0;
      border: 0;
      background: #000;
    }

    body.full-width #stream,
    body.full-width #streamCanvas {
      width: 100%;
      height: auto;
      max-width: 100%;
      max-height: none;
      object-fit: contain;
      margin: 0 auto;
    }

    #stream {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: none;
      background: #000;
    }

    #streamCanvas {
      width: 100%;
      height: 100%;
      display: none;
      background: #000;
    }

    #status {
      margin: 0;
      color: var(--muted);
      text-align: center;
      padding: 12px;
      pointer-events: none;
    }

    #loadingOverlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 8;
      background: radial-gradient(circle, rgba(6, 10, 18, 0.5) 0%, rgba(6, 10, 18, 0.12) 55%, rgba(6, 10, 18, 0) 75%);
    }

    #loadingOverlay.show {
      display: flex;
    }

    .loading-spinner {
      width: clamp(56px, 7vw, 78px);
      height: clamp(56px, 7vw, 78px);
      border-radius: 50%;
      background: conic-gradient(from 0deg, rgba(108, 176, 255, 0.1) 0deg, rgba(108, 176, 255, 0.35) 180deg, rgba(108, 176, 255, 0.98) 330deg, rgba(108, 176, 255, 0.1) 360deg);
      -webkit-mask: radial-gradient(farthest-side, transparent calc(100% - 7px), #000 calc(100% - 6px));
      mask: radial-gradient(farthest-side, transparent calc(100% - 7px), #000 calc(100% - 6px));
      filter: drop-shadow(0 0 20px rgba(108, 176, 255, 0.28));
      animation: loadingSpin 0.9s linear infinite;
    }

    #screenOverlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 5;
    }

    #screenOverlay.clickable {
      pointer-events: auto;
    }

    #screenOverlay.show {
      display: flex;
    }

    #screenOverlay.fade {
      animation: overlayFade 0.8s ease-out forwards;
    }

    .overlay-pill {
      width: 74px;
      height: 74px;
      border-radius: 999px;
      background: rgba(8, 12, 18, 0.74);
      border: 1px solid rgba(120, 140, 165, 0.55);
      display: grid;
      place-items: center;
      color: #fff;
      font-size: 1.5rem;
      line-height: 1;
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.45);
      cursor: default;
    }

    .overlay-pill.clickable {
      cursor: pointer;
    }

    .player-controls {
      position: absolute;
      left: 10px;
      right: 10px;
      bottom: 10px;
      z-index: 6;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      align-items: stretch;
      background: transparent;
      border: 0;
      border-radius: 0;
      padding: 0;
      backdrop-filter: none;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .player-controls-buttons {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      width: 100%;
      gap: 0;
    }

    #overlayPlayPause {
      justify-self: start;
    }

    #overlayFullWidth {
      justify-self: center;
    }

    #overlayMute {
      justify-self: end;
    }

    .live-audio-start {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 7;
      min-height: 56px;
      min-width: 180px;
      padding: 0 18px;
      border-radius: 999px;
      font-size: 1rem;
      font-weight: 700;
      border: 1px solid #78aee6;
      background: rgba(30, 68, 105, 0.92);
      color: #fff;
      display: none;
      touch-action: manipulation;
    }

    .live-audio-start.show {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .player-controls.show {
      opacity: 1;
      pointer-events: auto;
    }

    .control-btn {
      width: clamp(88px, 12vw, 108px);
      height: clamp(88px, 12vw, 108px);
      min-width: 88px;
      min-height: 88px;
      border-radius: 14px;
      border: 1px solid rgba(169, 202, 244, 0.58);
      background: rgba(9, 16, 28, 0.38);
      box-shadow: inset 0 0 0 1px rgba(208, 228, 255, 0.08), 0 6px 20px rgba(0, 0, 0, 0.28);
      backdrop-filter: blur(6px);
      font-weight: 700;
      padding: 0;
      display: grid;
      place-items: center;
      touch-action: manipulation;
      transition: background 140ms ease, border-color 140ms ease, transform 100ms ease;
    }

    .control-btn:hover {
      background: rgba(16, 28, 46, 0.5);
      border-color: rgba(188, 218, 255, 0.8);
    }

    .control-btn:active {
      transform: translateY(1px);
    }

    .control-btn-icon {
      width: var(--overlay-icon-size);
      height: var(--overlay-icon-size);
      object-fit: contain;
      display: block;
      pointer-events: none;
      user-select: none;
    }

    #overlayMute:not(.is-muted) .control-btn-icon {
      opacity: 0.82;
    }

    #overlayMute.is-muted {
      border-color: #78aee6;
      background: #24466a;
    }

    .seek-wrap {
      min-width: 0;
      display: grid;
      gap: 4px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(139, 171, 212, 0.35);
      background: rgba(8, 14, 24, 0.36);
      backdrop-filter: blur(4px);
    }

    #seekBar {
      width: 100%;
      margin: 0;
      padding: 0;
      appearance: none;
      -webkit-appearance: none;
      background: transparent;
      height: 44px;
      touch-action: pan-x;
    }

    #seekBar:focus {
      outline: none;
    }

    #seekBar::-webkit-slider-runnable-track {
      height: 8px;
      border-radius: 999px;
      background: #25384f;
      border: 1px solid #3c5472;
    }

    #seekBar::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #6cb0ff;
      border: 2px solid #dbeaff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
      margin-top: -12px;
      cursor: pointer;
    }

    #seekBar::-moz-range-track {
      height: 8px;
      border-radius: 999px;
      background: #25384f;
      border: 1px solid #3c5472;
    }

    #seekBar::-moz-range-thumb {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #6cb0ff;
      border: 2px solid #dbeaff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
      cursor: pointer;
    }

    #seekBar::-moz-range-progress {
      height: 8px;
      border-radius: 999px;
      background: #6cb0ff;
    }

    .time-label {
      color: #c7d7ea;
      font-size: 0.82rem;
      text-align: right;
    }

    @keyframes overlayFade {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }

    @keyframes loadingSpin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    #audio {
      display: none;
    }

    body.full-width .plex,
    body.full-width #playerForm,
    body.full-width .video-settings,
    body.full-width .status-row,
    body.full-width .plex-history {
      display: none;
    }

    @media (min-width: 760px) {
      .video-settings-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="plex">
      <input id="plexSearch" type="text" placeholder="Search Plex library...">
      <div id="plexSuggest"></div>
      <div id="plexBrowser"></div>
    </section>

    <form id="playerForm">
      <button id="channelsBtn" type="button">Channels</button>
      <input id="urlInput" type="url" placeholder="Paste MP4/MOV/WebM URL" value="https://blandfx.com/proxy/ts/stream/d7c78acb-fb75-4d24-a183-f15a2bcaa691" required>
      <button type="submit">Play</button>
    </form>
    <p id="urlSource" class="url-source">Loaded from address bar URL parameter.</p>

    <section id="videoSettingsPanel" class="video-settings">
      <div class="video-settings-head">
        <h3 class="video-settings-title">Video Settings</h3>
        <div class="video-settings-head-right">
          <p class="video-settings-subtitle">Tune stream quality and bandwidth</p>
          <button id="videoSettingsToggleBtn" type="button" aria-expanded="true">Collapse</button>
        </div>
      </div>
      <div class="video-settings-grid">
        <div class="setting-card">
          <div class="setting-label">Video Renderer</div>
          <div class="renderer-options">
            <input id="rendererMjpeg" class="renderer-radio" type="radio" name="playerMode" value="mjpeg" checked>
            <label for="rendererMjpeg" class="renderer-option">
              <span class="renderer-option-text">
                <span class="renderer-option-title">MJPEG (Legacy)</span>
                <span class="renderer-option-subtitle">Compatibility-first mode</span>
              </span>
            </label>
            <input id="rendererH264" class="renderer-radio" type="radio" name="playerMode" value="webcodecs_h264">
            <label for="rendererH264" class="renderer-option">
              <span class="renderer-option-text">
                <span class="renderer-option-title">WebCodecs H.264</span>
                <span class="renderer-option-subtitle">Modern decoder with smoother playback</span>
              </span>
            </label>
          </div>
        </div>
        <div id="mjpegQualityCard" class="setting-card">
          <div class="quality-block">
            <span class="setting-label">MJPEG Quality (q:v)</span>
            <div class="quality-slider-row">
              <input id="qualityInput" type="range" min="2" max="31" step="1" value="14">
              <strong id="qualityValue">14</strong>
            </div>
            <div class="quality-note">Lower value = higher quality / more bandwidth. Higher value = lower quality / less bandwidth.</div>
          </div>
        </div>
        <div id="h264QualityCard" class="setting-card">
          <div class="quality-block">
            <span class="setting-label">H264 Quality (QP/CRF)</span>
            <div class="quality-slider-row">
              <input id="h264QualityInput" type="range" min="10" max="40" step="1" value="25">
              <strong id="h264QualityValue">25</strong>
            </div>
            <div class="quality-note">Lower value = higher quality / more bandwidth. Used for WebCodecs H264 mode.</div>
          </div>
        </div>
      </div>
      <div class="video-settings-actions">
        <button id="applyVideoSettingsBtn" type="button">Apply Video Settings</button>
      </div>
    </section>

    <section id="screen" class="screen">
      <img id="stream" alt="Transcoded stream output">
      <canvas id="streamCanvas"></canvas>
      <p id="status">Enter a video URL and press Play.</p>
      <div id="loadingOverlay" aria-hidden="true"><div class="loading-spinner"></div></div>
      <div id="screenOverlay"><button id="overlayIcon" class="overlay-pill" type="button" aria-label="Play">â–¶</button></div>
      <div id="playerControls" class="player-controls">
        <div class="player-controls-buttons">
          <button id="overlayPlayPause" class="control-btn" type="button" aria-label="Play" disabled>
            <img id="overlayPlayPauseIcon" class="control-btn-icon" src="./play.png" alt="">
          </button>
          <button id="overlayFullWidth" class="control-btn" type="button" aria-label="Enter full width">
            <img id="overlayFullWidthIcon" class="control-btn-icon" src="./fullscreen.png" alt="">
          </button>
          <button id="overlayMute" class="control-btn" type="button" aria-label="Mute audio">
            <img id="overlayMuteIcon" class="control-btn-icon" src="./mute.png" alt="">
          </button>
        </div>
        <div class="seek-wrap">
          <input id="seekBar" type="range" min="0" max="100" step="0.1" value="0" disabled>
          <div id="timeLabel" class="time-label">00:00 / --:--</div>
        </div>
      </div>
    </section>

    <audio id="audio" preload="auto"></audio>
    <video id="liveMasterVideo" playsinline preload="auto" style="display:none"></video>
    <section class="status-row">
      <p id="syncInfo" class="status-chip">Sync: idle</p>
      <div id="videoPathMonitor" class="status-chip">Video: --</div>
      <div id="fpsMonitor" class="status-chip">FPS: --</div>
      <div id="bandwidthMonitor" class="status-chip">Bandwidth: --</div>
    </section>
    <section class="plex-history">
      <h3 class="plex-history-title">Plex History</h3>
      <div id="plexHistoryList" class="plex-history-list"></div>
    </section>
  </main>

  <div id="channelsModal" class="channels-modal" role="dialog" aria-modal="true" aria-labelledby="channelsTitle">
    <div class="channels-panel">
      <div class="channels-head">
        <h3 id="channelsTitle">Channel Picker</h3>
        <button id="channelsCloseBtn" type="button">Close</button>
      </div>
      <div class="channels-search">
        <input id="channelsSearch" type="text" placeholder="Filter channels...">
      </div>
      <div id="channelsList"></div>
    </div>
  </div>

  <script>
    const form = document.getElementById('playerForm');
    const input = document.getElementById('urlInput');
    const channelsBtn = document.getElementById('channelsBtn');
    const channelsModal = document.getElementById('channelsModal');
    const channelsCloseBtn = document.getElementById('channelsCloseBtn');
    const channelsSearch = document.getElementById('channelsSearch');
    const channelsList = document.getElementById('channelsList');
    const urlSource = document.getElementById('urlSource');
    const plexSearch = document.getElementById('plexSearch');
    const plexSuggest = document.getElementById('plexSuggest');
    const plexBrowser = document.getElementById('plexBrowser');
    const plexHistoryList = document.getElementById('plexHistoryList');
    const screen = document.getElementById('screen');
    const stream = document.getElementById('stream');
    const streamCanvas = document.getElementById('streamCanvas');
    const screenOverlay = document.getElementById('screenOverlay');
    const overlayIcon = document.getElementById('overlayIcon');
    const playerControls = document.getElementById('playerControls');
    const overlayPlayPauseBtn = document.getElementById('overlayPlayPause');
    const overlayPlayPauseIcon = document.getElementById('overlayPlayPauseIcon');
    const fullWidthBtn = document.getElementById('overlayFullWidth');
    const fullWidthIcon = document.getElementById('overlayFullWidthIcon');
    const muteBtn = document.getElementById('overlayMute');
    const seekBar = document.getElementById('seekBar');
    const timeLabel = document.getElementById('timeLabel');
    const statusEl = document.getElementById('status');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const syncInfo = document.getElementById('syncInfo');
    const audio = document.getElementById('audio');
    const liveMasterVideo = document.getElementById('liveMasterVideo');
    const videoSettingsPanel = document.getElementById('videoSettingsPanel');
    const videoSettingsToggleBtn = document.getElementById('videoSettingsToggleBtn');
    const playerModeInputs = Array.from(document.querySelectorAll('input[name="playerMode"]'));
    const mjpegQualityCard = document.getElementById('mjpegQualityCard');
    const h264QualityCard = document.getElementById('h264QualityCard');
    const qualityInput = document.getElementById('qualityInput');
    const qualityValue = document.getElementById('qualityValue');
    const h264QualityInput = document.getElementById('h264QualityInput');
    const h264QualityValue = document.getElementById('h264QualityValue');
    const applyVideoSettingsBtn = document.getElementById('applyVideoSettingsBtn');
    const videoPathMonitor = document.getElementById('videoPathMonitor');
    const fpsMonitor = document.getElementById('fpsMonitor');
    const bandwidthMonitor = document.getElementById('bandwidthMonitor');
    let pendingAudioStart = false;
    let liveAudioRequestedAtMs = 0;
    let liveAudioReadyAtMs = 0;
    let liveFirstFrameAtMs = 0;
    let liveStartupSeekApplied = false;
    let liveStartupWaitUntilMs = 0;
    let liveFirstFrameRetryTimer = null;
    let liveFirstFrameRetries = 0;
    let freezeOnNextFrame = false;
    let syncTimer = null;
    let syncSource = null;
    let activeSessionId = '';
    let lastVideoClock = 0;
    let hasVideoFrame = false;
    let isPaused = false;
    let suppressStreamError = false;
    let currentIsLiveStream = false;
    let mediaBaseTime = 0;
    let pausePositionSeconds = 0;
    let pausedFrameDataUrl = '';
    let overlayFadeTimer = null;
    let controlsHideTimer = null;
    let isSeeking = false;
    let seekRangeMax = 100;
    let knownDurationSeconds = NaN;
    let liveTunerActive = false;
    let liveTunerApplied = false;
    let liveTunerStartAt = 0;
    let liveTunerSamples = [];
    let manualOffsetEdited = false;
    let previousSyncTarget = 0;
    let manualNudgeDirection = 0;
    let manualNudgeUntilMs = 0;
    let syncFilteredError = 0;
    let syncIntegralError = 0;
    let lastSyncSampleAtMs = 0;
    let lastLargeDriftCorrectionAtMs = 0;
    let lastLiveAudioReloadAtMs = 0;
    let lastLiveBufferedCatchupAtMs = 0;
    let lastVideoRawClock = NaN;
    let lastAudioRawClock = NaN;
    let liveAudioOriginRawClock = NaN;
    let livePipelineGapEstimate = 0;
    let liveAudioPlayIssuedAtMs = 0;
    let liveAwaitingFirstPlaying = false;
    let liveStartupPlayDelayAdjusted = false;
    let liveFrameLoadCount = 0;
    let liveFirstFrameLoadAtMs = 0;
    let liveLastFrameLoadAtMs = 0;
    let lastLiveEdgeSnapAtMs = 0;
    let liveTimingMode = 'master';
    let liveVideoHoldActive = false;
    let liveVideoHoldUntilMs = 0;
    let liveVideoHoldTimer = null;
    let liveAudioHoldActive = false;
    let liveAudioHoldTimer = null;
    let liveHoldCooldownUntilMs = 0;
    let lastLiveHardSyncAtMs = 0;
    let lastPresentedVideoClock = NaN;
    let lastPresentedVideoAtMs = 0;
    let lastVideoResyncAtMs = 0;
    let renderedFrameTimesMs = [];
    let currentVideoRenderer = 'mjpeg';
    let wcDecoder = null;
    let wcFetchAbort = null;
    let wcJobToken = 0;
    let wcCanvasCtx = null;
    let wcFrameQueue = [];
    let wcFrameQueueMax = 180;
    let wcRenderRaf = 0;
    let wcDecodedCount = 0;
    let wcRenderedCount = 0;
    let wcDecodeDone = false;
    const LIVE_STARTUP_BUFFER_WAIT_MS = 3000;
    const LIVE_STARTUP_CLOCK_WAIT_MS = 3000;
    const LIVE_STARTUP_MIN_FRAME_EVENTS = 2;
    const LIVE_STARTUP_FRAME_GATE_TIMEOUT_MS = 2200;
    const LIVE_STARTUP_FRAME_GATE_HARD_TIMEOUT_MS = 7000;
    const LIVE_STARTUP_FRAME_SPAN_MIN_MS = 250;
    const LIVE_STARTUP_FRAME_RECENT_MS = 900;
    const LIVE_START_DELAY_SEEK_MIN = 0.18;
    const LIVE_START_DELAY_SEEK_MAX = 4.0;
    const LIVE_STARTUP_SEEK_THRESHOLD = 0.35;
    const LIVE_STARTUP_SEEK_MAX = 30.0;
    const LIVE_STARTUP_BUFFER_SLACK = 0.08;
    const LIVE_DEAD_BAND = 0.035;
    const LIVE_RATE_P = 0.22;
    const LIVE_RATE_I = 0.05;
    const LIVE_RATE_SLEW = 0.5;
    const LIVE_RATE_INTEGRAL_CLAMP = 4.0;
    const LIVE_RATE_MIN = 0.88;
    const LIVE_RATE_MAX = 1.12;
    const LIVE_RATE_MIN_LARGE = 0.8;
    const LIVE_RATE_MAX_LARGE = 1.2;
    const LIVE_RATE_MIN_VERY_LARGE = 0.72;
    const LIVE_RATE_MAX_VERY_LARGE = 1.28;
    const LIVE_LARGE_DRIFT_CORRECTION_THRESHOLD = 9.0;
    const LIVE_LARGE_DRIFT_CORRECTION_MAX_STEP = 4.0;
    const LIVE_LARGE_DRIFT_CORRECTION_COOLDOWN_MS = 120000;
    const LIVE_AUDIO_RELOAD_COOLDOWN_MS = 15000;
    const LIVE_BUFFERED_CATCHUP_THRESHOLD = 1.25;
    const LIVE_BUFFERED_CATCHUP_COOLDOWN_MS = 8000;
    const LIVE_BUFFERED_CATCHUP_MAX_STEP = 5.0;
    const LIVE_TUNER_WINDOW_MS = 12000;
    const LIVE_TUNER_MIN_SAMPLES = 16;
    const LIVE_TUNER_MAX_ABS_TARGET = 0.45;
    const LIVE_PIPELINE_GAP_ALPHA = 0.12;
    const LIVE_PIPELINE_GAP_MAX = 8.0;
    const LIVE_AUDIO_EDGE_LAG_THRESHOLD = 1.25;
    const LIVE_AUDIO_EDGE_SNAP_COOLDOWN_MS = 4000;
    const LIVE_USE_VIDEO_HOLD_CATCHUP = true;
    const LIVE_VIDEO_HOLD_TRIGGER_SECONDS = 0.45;
    const LIVE_VIDEO_HOLD_MIN_MS = 250;
    const LIVE_VIDEO_HOLD_MAX_MS = 2600;
    const TARGET_VIDEO_FPS = 30;
    const LIVE_AUDIO_HOLD_TRIGGER_SECONDS = 999;
    const LIVE_AUDIO_HOLD_MIN_MS = 180;
    const LIVE_AUDIO_HOLD_MAX_MS = 1800;
    const LIVE_HOLD_COOLDOWN_MS = 450;
    const LIVE_HARD_SYNC_THRESHOLD = 2.5;
    const LIVE_HARD_SYNC_MAX_STEP = 12.0;
    const LIVE_HARD_SYNC_COOLDOWN_MS = 6000;
    const LIVE_ALLOW_LARGE_SEEK_CORRECTIONS = false;
    const LIVE_ALLOW_BUFFERED_CATCHUP = false;
    const LIVE_ALLOW_EDGE_SNAP = false;
    const AUDIO_MASTER_SYNC_MODE = false;
    const VIDEO_AUDIO_MASTER_RESYNC_THRESHOLD_SEC = 0.45;
    const VIDEO_AUDIO_MASTER_RESYNC_COOLDOWN_MS = 900;
    const VIDEO_AUDIO_MASTER_STALE_FRAME_SEC = 0.55;
    const VIDEO_AUDIO_MASTER_RESYNC_THRESHOLD_H264_SEC = 1.2;
    const VIDEO_AUDIO_MASTER_STALE_FRAME_H264_SEC = 2.0;
    const VIDEO_AUDIO_MASTER_RESYNC_COOLDOWN_H264_MS = 2500;
    const WC_AUDIO_MASTER_RENDER_LAG_SEC = 0.08;
    const WC_AUDIO_MASTER_DROP_LATE_SEC = 0.22;
    const WC_AUDIO_MASTER_DROP_MIN_QUEUE = 3;
    const WC_AUDIO_MASTER_RENDER_EARLY_SEC = 0.010;
    const FPS_WINDOW_MS = 2500;
    const DEBUG_QUERY_PARAM = new URLSearchParams(window.location.search).get('debug');
    const LIVE_DEBUG = DEBUG_QUERY_PARAM === '1' || localStorage.getItem('splayDebug') === '1';
    const LAST_PLAYBACK_STORAGE_KEY = 'splay:lastPlayback:v1';
    const VIDEO_SETTINGS_STORAGE_KEY = 'splay:videoSettings:v1';
    const VIDEO_SETTINGS_COLLAPSED_STORAGE_KEY = 'splay:videoSettingsCollapsed:v1';
    let plexSearchTimer = null;
    let plexSearchRequestSeq = 0;
    let bandwidthTimer = null;
    let liveDebugLastGateLogMs = 0;
    let liveDebugLastGateReason = '';
    let currentMediaUrl = '';
    let currentSessionMode = 'direct';
    let restoreResumeState = null;
    let channelsCatalog = [];
    let autoRestoreSubmitPending = false;
    let currentPlexMeta = null;
    let lastMediaTapAtMs = 0;
    let lastMediaTapX = 0;
    let lastMediaTapY = 0;
    let pageScrollBeforeFullWidth = 0;
    const PLEX_HISTORY_MAX_ITEMS = 80;
    const PLEX_HISTORY_UPSERT_MIN_INTERVAL_MS = 2500;
    const PLEX_SYNC_PUSH_INTERVAL_MS = 10000;
    const PLEX_SYNC_PULL_INTERVAL_MS = 300000;
    let plexHistoryCache = [];
    let plexHistoryLoaded = false;
    let plexHistoryLoadInFlight = null;
    let plexHistoryUpsertInFlight = false;
    let plexHistoryPendingItem = null;
    let plexHistoryLastUpsertAtMs = 0;
    let plexSyncPushInFlight = false;
    let plexSyncLastPushAtMs = 0;
    let plexSyncPendingPayload = null;
    let plexSyncLastPullAtMs = 0;

    function getLiveTimingMedia() {
      if (currentIsLiveStream) return liveMasterVideo;
      return liveMasterVideo;
    }

    function getAudioMasterMedia() {
      return currentIsLiveStream ? getLiveTimingMedia() : audio;
    }

    function markPresentedVideoFrame(masterTimeSec) {
      let t = Number(masterTimeSec);
      if (!Number.isFinite(t)) {
        const media = getAudioMasterMedia();
        if (media && Number.isFinite(media.currentTime)) {
          t = media.currentTime;
        }
      }
      if (!Number.isFinite(t)) return;
      lastPresentedVideoClock = Math.max(0, t);
      lastPresentedVideoAtMs = performance.now();
    }

    function resetPresentedVideoClock() {
      lastPresentedVideoClock = NaN;
      lastPresentedVideoAtMs = 0;
    }

    function noteRenderedFrame() {
      const now = performance.now();
      renderedFrameTimesMs.push(now);
      const cutoff = now - FPS_WINDOW_MS;
      while (renderedFrameTimesMs.length && renderedFrameTimesMs[0] < cutoff) {
        renderedFrameTimesMs.shift();
      }
      renderFpsMonitor();
    }

    function getRealtimeFps() {
      const now = performance.now();
      const cutoff = now - FPS_WINDOW_MS;
      while (renderedFrameTimesMs.length && renderedFrameTimesMs[0] < cutoff) {
        renderedFrameTimesMs.shift();
      }
      if (renderedFrameTimesMs.length < 2) {
        return 0;
      }
      const first = renderedFrameTimesMs[0];
      const last = renderedFrameTimesMs[renderedFrameTimesMs.length - 1];
      const spanSec = Math.max(0.001, (last - first) / 1000);
      return (renderedFrameTimesMs.length - 1) / spanSec;
    }

    function getFrameJitterMs() {
      if (renderedFrameTimesMs.length < 4) {
        return NaN;
      }
      const intervals = [];
      for (let i = 1; i < renderedFrameTimesMs.length; i += 1) {
        intervals.push(renderedFrameTimesMs[i] - renderedFrameTimesMs[i - 1]);
      }
      if (intervals.length < 3) {
        return NaN;
      }
      let sum = 0;
      for (const v of intervals) sum += v;
      const mean = sum / intervals.length;
      let varSum = 0;
      for (const v of intervals) {
        const d = v - mean;
        varSum += d * d;
      }
      return Math.sqrt(varSum / intervals.length);
    }

    function resetRealtimeFps() {
      renderedFrameTimesMs = [];
      renderFpsMonitor();
    }

    function renderFpsMonitor() {
      const fps = getRealtimeFps();
      if (!Number.isFinite(fps) || fps <= 0.1) {
        fpsMonitor.textContent = 'FPS: --';
        return;
      }
      const jitterMs = getFrameJitterMs();
      if (Number.isFinite(jitterMs)) {
        fpsMonitor.textContent = 'FPS: ' + fps.toFixed(1) + ' | Jit: ' + jitterMs.toFixed(1) + 'ms';
      } else {
        fpsMonitor.textContent = 'FPS: ' + fps.toFixed(1);
      }
    }

    function liveDebugLog(label, data) {
      if (!LIVE_DEBUG) return;
      const now = new Date();
      const ts = now.toTimeString().slice(0, 8) + '.' + String(now.getMilliseconds()).padStart(3, '0');
      if (data && typeof data === 'object') {
        console.log('[splay ' + ts + '] ' + label, data);
        return;
      }
      console.log('[splay ' + ts + '] ' + label);
    }

    function liveDebugGate(reason, details) {
      if (!LIVE_DEBUG) return;
      const now = performance.now();
      if (reason !== liveDebugLastGateReason || (now - liveDebugLastGateLogMs) > 1200) {
        liveDebugLastGateReason = reason;
        liveDebugLastGateLogMs = now;
        liveDebugLog('startup gate: ' + reason, details || null);
      }
    }

    function setFullWidthMode(enabled) {
      const wasFullWidth = document.body.classList.contains('full-width');
      if (enabled && !wasFullWidth) {
        pageScrollBeforeFullWidth = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;
      }
      document.body.classList.toggle('full-width', enabled);
      if (enabled) {
        window.scrollTo(0, 0);
        document.documentElement.scrollTop = 0;
        document.body.scrollTop = 0;
      } else if (wasFullWidth && pageScrollBeforeFullWidth > 0) {
        window.scrollTo(0, pageScrollBeforeFullWidth);
      }
      fullWidthIcon.src = './fullscreen.png';
      fullWidthBtn.setAttribute('aria-label', enabled ? 'Exit full width' : 'Enter full width');
    }

    function toggleFullWidthMode() {
      const enabled = !document.body.classList.contains('full-width');
      setFullWidthMode(enabled);
    }

    function applyAddressBarUrl() {
      const params = new URLSearchParams(window.location.search);
      const candidate = params.get('url') || params.get('stream');
      if (!candidate) return false;
      try {
        const parsed = new URL(candidate);
        if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') return false;
        input.value = candidate;
        currentMediaUrl = candidate;
        return true;
      } catch (_) {
        // Ignore invalid URL params silently.
        return false;
      }
    }

    function clampInteger(value, min, max, fallback) {
      const n = Number(value);
      if (!Number.isFinite(n)) return fallback;
      return Math.max(min, Math.min(max, Math.round(n)));
    }

    function getSelectedPlayerMode() {
      const selected = playerModeInputs.find(function (inputEl) {
        return !!inputEl.checked;
      });
      return selected && selected.value === 'webcodecs_h264' ? 'webcodecs_h264' : 'mjpeg';
    }

    function setSelectedPlayerMode(mode) {
      const target = mode === 'webcodecs_h264' ? 'webcodecs_h264' : 'mjpeg';
      for (const inputEl of playerModeInputs) {
        inputEl.checked = inputEl.value === target;
      }
    }

    function getVideoSettings() {
      const mode = getSelectedPlayerMode();
      return {
        mode,
        q: clampInteger(qualityInput.value, 2, 31, 14),
        h264Q: clampInteger(h264QualityInput.value, 10, 40, 25),
      };
    }

    function syncVideoSettingsInputs() {
      const settings = getVideoSettings();
      setSelectedPlayerMode(settings.mode);
      qualityInput.value = String(settings.q);
      qualityValue.textContent = String(settings.q);
      h264QualityInput.value = String(settings.h264Q);
      h264QualityValue.textContent = String(settings.h264Q);
      const mjpegMode = settings.mode === 'mjpeg';
      mjpegQualityCard.hidden = !mjpegMode;
      h264QualityCard.hidden = mjpegMode;
      qualityInput.disabled = !mjpegMode;
      h264QualityInput.disabled = mjpegMode;
    }

    function saveVideoSettings() {
      try {
        const settings = getVideoSettings();
        localStorage.setItem(VIDEO_SETTINGS_STORAGE_KEY, JSON.stringify(settings));
      } catch (_) {}
    }

    function restoreVideoSettings() {
      try {
        const raw = localStorage.getItem(VIDEO_SETTINGS_STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== 'object') return;
        setSelectedPlayerMode(String(parsed.mode || '').toLowerCase() === 'webcodecs_h264'
          ? 'webcodecs_h264'
          : 'mjpeg');
        qualityInput.value = String(clampInteger(parsed.q, 2, 31, 14));
        h264QualityInput.value = String(clampInteger(parsed.h264Q, 10, 40, 25));
      } catch (_) {}
    }

    function formatBitsPerSecond(value) {
      if (!Number.isFinite(value) || value <= 0) return '0 kbps';
      if (value >= 1_000_000) return (value / 1_000_000).toFixed(2) + ' Mbps';
      if (value >= 100_000) return (value / 1_000).toFixed(0) + ' kbps';
      return (value / 1_000).toFixed(1) + ' kbps';
    }

    function renderVideoPathMonitor(metrics) {
      if (!metrics || typeof metrics !== 'object') {
        videoPathMonitor.textContent = 'Video: --';
        return;
      }
      const rawRenderer = String(metrics.video_renderer || '').toLowerCase();
      const rawEncoder = String(metrics.video_encoder || '').toLowerCase();
      const renderer = rawRenderer === 'h264' ? 'H264' : 'MJPEG';
      const encoder = rawEncoder === 'vaapi' ? 'HW (VAAPI)' : 'CPU';
      videoPathMonitor.textContent = 'Video: ' + renderer + ' / ' + encoder;
    }

    function renderBandwidthMonitor(metrics) {
      if (!metrics || !Number.isFinite(metrics.total_bps)) {
        bandwidthMonitor.textContent = 'Bandwidth: --';
        renderVideoPathMonitor(metrics);
        return;
      }
      const totalText = formatBitsPerSecond(metrics.total_bps);
      const videoText = formatBitsPerSecond(Number(metrics.video_bps));
      const audioText = formatBitsPerSecond(Number(metrics.audio_bps));
      bandwidthMonitor.textContent = 'Bandwidth: ' + totalText + ' (V ' + videoText + ' / A ' + audioText + ')';
      renderVideoPathMonitor(metrics);
    }

    function clearBandwidthMonitorLoop() {
      if (bandwidthTimer !== null) {
        clearInterval(bandwidthTimer);
        bandwidthTimer = null;
      }
      renderBandwidthMonitor(null);
      renderFpsMonitor();
    }

    function startBandwidthMonitorLoop(sid) {
      clearBandwidthMonitorLoop();
      renderBandwidthMonitor(null);
      if (!sid) return;
      bandwidthTimer = setInterval(async function () {
        if (!activeSessionId || activeSessionId !== sid) return;
        try {
          const res = await fetch('./session/metrics?sid=' + encodeURIComponent(sid) + '&t=' + Date.now(), { cache: 'no-store' });
          if (!res.ok) return;
          const metrics = await res.json();
          renderBandwidthMonitor(metrics);
          renderFpsMonitor();
        } catch (_) {}
      }, 1000);
    }

    function setVideoSettingsCollapsed(collapsed) {
      videoSettingsPanel.classList.toggle('collapsed', !!collapsed);
      videoSettingsToggleBtn.textContent = collapsed ? 'Expand' : 'Collapse';
      videoSettingsToggleBtn.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
      try {
        localStorage.setItem(VIDEO_SETTINGS_COLLAPSED_STORAGE_KEY, collapsed ? '1' : '0');
      } catch (_) {}
    }

    function restoreVideoSettingsCollapsed() {
      try {
        const raw = localStorage.getItem(VIDEO_SETTINGS_COLLAPSED_STORAGE_KEY);
        setVideoSettingsCollapsed(raw === '1');
      } catch (_) {
        setVideoSettingsCollapsed(false);
      }
    }

    function getAbsolutePlaybackTime() {
      if (currentIsLiveStream) return 0;
      const rel = Number.isFinite(audio.currentTime) ? audio.currentTime : 0;
      return Math.max(0, mediaBaseTime + rel);
    }

    function parsePartIdFromUrl(url) {
      const value = String(url || '');
      const match = value.match(/\/library\/parts\/(\d+)/);
      return match ? match[1] : '';
    }

    function buildPlexSyncState(eventName) {
      const ev = String(eventName || '').toLowerCase();
      if (ev === 'pause') return 'paused';
      if (ev === 'stop' || ev === 'ended') return 'stopped';
      return 'playing';
    }

    function shouldMarkWatched(position, duration) {
      if (!Number.isFinite(position) || !Number.isFinite(duration) || duration <= 0) return false;
      return (position / duration) >= 0.9;
    }

    function savePlaybackState(force, syncEvent) {
      try {
        const url = String(currentMediaUrl || input.value || '').trim();
        if (!url) return;
        const payload = {
          url: url,
          is_live: !!currentIsLiveStream,
          position: currentIsLiveStream ? 0 : getAbsolutePlaybackTime(),
          known_duration: Number.isFinite(knownDurationSeconds) ? knownDurationSeconds : null,
          updated_at: Date.now(),
        };
        if (!force && !activeSessionId && payload.is_live) return;
        localStorage.setItem(LAST_PLAYBACK_STORAGE_KEY, JSON.stringify(payload));
        if (!payload.is_live) {
          upsertCurrentPlexHistory(force);
          const eventName = String(syncEvent || (force ? 'checkpoint' : 'tick'));
          queuePlexSyncPush(eventName, !!force);
        }
      } catch (_) {}
    }

    function restoreLastPlaybackFromStorage() {
      try {
        const raw = localStorage.getItem(LAST_PLAYBACK_STORAGE_KEY);
        if (!raw) return false;
        const saved = JSON.parse(raw);
        if (!saved || typeof saved.url !== 'string' || !saved.url.trim()) return false;
        input.value = saved.url.trim();
        currentMediaUrl = input.value;
        if (saved.is_live) {
          return true;
        }
        const pos = Number(saved.position);
        const dur = Number(saved.known_duration);
        restoreResumeState = {
          url: input.value,
          position: Number.isFinite(pos) && pos > 0 ? pos : 0,
          knownDuration: Number.isFinite(dur) && dur > 0 ? dur : NaN,
          paused: true,
        };
        if (Number.isFinite(restoreResumeState.knownDuration)) {
          knownDurationSeconds = restoreResumeState.knownDuration;
        }
        setTimeout(function () {
          autoRestoreSubmitPending = true;
          form.requestSubmit();
        }, 0);
        return true;
      } catch (_) {
        return false;
      }
    }

    function getBufferedEndSeconds() {
      try {
        const media = currentIsLiveStream ? getLiveTimingMedia() : audio;
        const ranges = media.buffered;
        if (!ranges || ranges.length < 1) return NaN;
        const end = ranges.end(ranges.length - 1);
        return Number.isFinite(end) ? end : NaN;
      } catch (_) {
        return NaN;
      }
    }

    async function maybeStartPendingLiveAudio() {
      if (!currentIsLiveStream || !pendingAudioStart || isPaused) {
        liveDebugGate('inactive', {
          live: currentIsLiveStream,
          pendingAudioStart,
          isPaused,
        });
        return false;
      }
      const media = getLiveTimingMedia();
      if (!hasVideoFrame || media.readyState < 2) {
        liveDebugGate('waiting media readiness', {
          hasVideoFrame,
          mediaReadyState: media.readyState,
        });
        return false;
      }
      if (liveFirstFrameLoadAtMs > 0) {
        const nowMs = performance.now();
        const sinceFirstFrameMs = nowMs - liveFirstFrameLoadAtMs;
        const frameGateTimedOut = sinceFirstFrameMs >= LIVE_STARTUP_FRAME_GATE_TIMEOUT_MS;
        const frameGateHardTimedOut = sinceFirstFrameMs >= LIVE_STARTUP_FRAME_GATE_HARD_TIMEOUT_MS;
        const enoughFrameEvents = liveFrameLoadCount >= LIVE_STARTUP_MIN_FRAME_EVENTS;
        const frameSpanMs = Math.max(0, liveLastFrameLoadAtMs - liveFirstFrameLoadAtMs);
        const hasFrameMotion = enoughFrameEvents && frameSpanMs >= LIVE_STARTUP_FRAME_SPAN_MIN_MS;
        const frameRecentlyUpdated = (nowMs - liveLastFrameLoadAtMs) <= LIVE_STARTUP_FRAME_RECENT_MS;
        if (!frameGateHardTimedOut) {
          if (!hasFrameMotion && !frameGateTimedOut) {
            syncInfo.textContent = 'Sync: waiting for stable video frames...';
            liveDebugGate('waiting stable frames', {
              liveFrameLoadCount,
              frameSpanMs,
              sinceFirstFrameMs,
            });
            return false;
          }
          if (!hasFrameMotion && frameGateTimedOut) {
            syncInfo.textContent = 'Sync: waiting for next video frame...';
            liveDebugGate('waiting next frame', {
              liveFrameLoadCount,
              frameSpanMs,
              sinceFirstFrameMs,
            });
            return false;
          }
          if (!frameRecentlyUpdated && !frameGateTimedOut) {
            syncInfo.textContent = 'Sync: waiting for video motion...';
            liveDebugGate('waiting frame motion', {
              sinceLastFrameMs: nowMs - liveLastFrameLoadAtMs,
              frameSpanMs,
            });
            return false;
          }
        }
      }
      if (!Number.isFinite(liveAudioReadyAtMs) || liveAudioReadyAtMs <= 0) {
        syncInfo.textContent = 'Sync: waiting for audio buffer...';
        liveDebugGate('waiting audio buffer', {
          liveAudioReadyAtMs,
          mediaReadyState: media.readyState,
        });
        return false;
      }
      const aMs = liveAudioReadyAtMs;
      const bMs = performance.now();
      let startupSeek = Math.max(0, (bMs - aMs) / 1000);
      const targetOffset = getTargetOffsetSeconds();
      startupSeek += targetOffset;
      startupSeek = Math.max(0, Math.min(LIVE_STARTUP_SEEK_MAX, startupSeek));
      const bufferedEnd = getBufferedEndSeconds();

      if (Number.isFinite(bufferedEnd)) {
        const latestSafe = Math.max(0, bufferedEnd - LIVE_STARTUP_BUFFER_SLACK);
        if (startupSeek > latestSafe) {
          if (performance.now() < liveStartupWaitUntilMs) {
            syncInfo.textContent = 'Sync: waiting for audio buffer...';
            liveDebugGate('waiting buffered slack', {
              startupSeek,
              latestSafe,
              bufferedEnd,
            });
            return false;
          }
          startupSeek = latestSafe;
        }
      }

      if (!liveStartupSeekApplied && startupSeek > LIVE_STARTUP_SEEK_THRESHOLD) {
        try {
          media.currentTime = startupSeek;
          syncInfo.textContent = 'Sync: startup align +' + startupSeek.toFixed(2) + 's'
            + ' (b-a ' + Math.max(0, (bMs - aMs) / 1000).toFixed(2) + 's)';
        } catch (_) {
          // Ignore browser seek refusal and continue with rate-only correction.
        }
      }

      liveStartupSeekApplied = true;
      pendingAudioStart = false;
      syncFilteredError = 0;
      syncIntegralError = 0;
      lastSyncSampleAtMs = 0;
      liveAudioPlayIssuedAtMs = performance.now();
      liveAwaitingFirstPlaying = true;
      liveStartupPlayDelayAdjusted = false;
      updateLiveStartAudioButton();
      liveDebugLog('startup pass -> attemptAudioPlay', {
        aMs,
        bMs,
        startupSeek,
        bufferedEnd,
      });
      await attemptAudioPlay();
      return true;
    }

    function clearSyncTimer() {
      clearBandwidthMonitorLoop();
      if (syncTimer !== null) {
        clearInterval(syncTimer);
        syncTimer = null;
      }
      if (syncSource) {
        syncSource.close();
        syncSource = null;
      }
    }

    function clearLiveFirstFrameRetry() {
      if (liveFirstFrameRetryTimer) {
        clearTimeout(liveFirstFrameRetryTimer);
        liveFirstFrameRetryTimer = null;
      }
    }

    function scheduleLiveFirstFrameRetry() {
      clearLiveFirstFrameRetry();
      if (!currentIsLiveStream || isPaused || hasVideoFrame || !activeSessionId) return;
      liveDebugLog('schedule first-frame retry', {
        liveFirstFrameRetries,
        activeSessionId,
      });
      liveFirstFrameRetryTimer = setTimeout(function () {
        liveFirstFrameRetryTimer = null;
        if (!currentIsLiveStream || isPaused || hasVideoFrame || !activeSessionId) return;
        if (liveFirstFrameRetries >= 3) {
          syncInfo.textContent = 'Sync: could not get first video frame';
          liveDebugLog('first-frame retry exhausted', { liveFirstFrameRetries });
          return;
        }
        liveFirstFrameRetries += 1;
        liveDebugLog('first-frame retry firing', { liveFirstFrameRetries });
        suppressStreamError = true;
        stream.src = '';
        setStreamFromTime(0);
        syncInfo.textContent = 'Sync: retrying first video frame... (' + liveFirstFrameRetries + ')';
      }, 15000);
    }

    function hidePlexSuggestions() {
      plexSuggest.style.display = 'none';
      plexSuggest.innerHTML = '';
    }

    function hidePlexBrowser() {
      plexBrowser.style.display = 'none';
      plexBrowser.innerHTML = '';
    }

    function closeChannelsModal() {
      channelsModal.classList.remove('show');
    }

    function sanitizePlexHistoryItem(item) {
      if (!item || typeof item !== 'object') return null;
      const url = String(item.url || '').trim();
      const title = String(item.title || '').trim();
      if (!url || !title) return null;
      const position = Number(item.position);
      const knownDuration = Number(item.known_duration);
      const contentId = String(item.content_id || '').trim();
      const partId = String(item.part_id || '').trim() || parsePartIdFromUrl(url);
      const plexUpdatedAt = Number(item.plex_updated_at);
      const source = String(item.source || '').trim().toLowerCase();
      return {
        url: url,
        title: title,
        type: String(item.type || 'item'),
        position: Number.isFinite(position) && position >= 0 ? position : 0,
        known_duration: Number.isFinite(knownDuration) && knownDuration > 0 ? knownDuration : null,
        updated_at: Number(item.updated_at) || Date.now(),
        plex_updated_at: Number.isFinite(plexUpdatedAt) && plexUpdatedAt > 0 ? Math.trunc(plexUpdatedAt) : null,
        content_id: contentId,
        part_id: partId,
        source: source || null,
      };
    }

    function normalizePlexHistoryList(list) {
      if (!Array.isArray(list)) return [];
      const out = [];
      for (const item of list) {
        const normalized = sanitizePlexHistoryItem(item);
        if (!normalized) continue;
        // Only show items that were viewed in Splay (splay/merged/legacy).
        if (normalized.source === 'plex') continue;
        out.push(normalized);
      }
      out.sort(function (a, b) {
        return (Number(b.updated_at) || 0) - (Number(a.updated_at) || 0);
      });
      return out.slice(0, PLEX_HISTORY_MAX_ITEMS);
    }

    function applyPlexHistoryCache(nextList) {
      plexHistoryCache = normalizePlexHistoryList(nextList);
      renderPlexHistory();
    }

    function renderPlexHistory() {
      const items = normalizePlexHistoryList(plexHistoryCache);
      plexHistoryList.innerHTML = '';
      if (!items.length) {
        const empty = document.createElement('div');
        empty.className = 'plex-history-empty';
        empty.textContent = 'No Plex history yet.';
        plexHistoryList.appendChild(empty);
        return;
      }
      for (const item of items) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'plex-history-item';

        const main = document.createElement('div');
        main.className = 'plex-history-main';
        const name = document.createElement('div');
        name.className = 'plex-history-name';
        name.textContent = item.title;
        main.appendChild(name);

        const meta = document.createElement('div');
        meta.className = 'plex-history-meta';
        const pos = Number(item.position);
        const dur = Number(item.known_duration);
        const posText = Number.isFinite(pos) && pos >= 0 ? formatClock(pos) : '--:--';
        const durText = Number.isFinite(dur) && dur > 0 ? formatClock(dur) : '--:--';
        const typeText = item.type ? String(item.type) : 'item';
        meta.textContent = typeText + ' â€¢ ' + posText + ' / ' + durText;
        main.appendChild(meta);
        btn.appendChild(main);

        const removeBtn = document.createElement('div');
        removeBtn.className = 'plex-history-remove';
        removeBtn.textContent = 'Ã—';
        removeBtn.title = 'Remove';
        removeBtn.setAttribute('aria-label', 'Remove from Plex history');
        removeBtn.setAttribute('role', 'button');
        removeBtn.tabIndex = 0;
        removeBtn.addEventListener('click', function (event) {
          event.preventDefault();
          event.stopPropagation();
          void deletePlexHistoryItem(item.url);
        });
        removeBtn.addEventListener('keydown', function (event) {
          if (event.key !== 'Enter' && event.key !== ' ') return;
          event.preventDefault();
          event.stopPropagation();
          void deletePlexHistoryItem(item.url);
        });
        btn.appendChild(removeBtn);

        btn.addEventListener('click', function () {
          currentPlexMeta = {
            url: item.url,
            title: item.title,
            type: item.type || 'item',
            content_id: item.content_id || '',
            part_id: item.part_id || parsePartIdFromUrl(item.url),
          };
          restoreResumeState = {
            url: item.url,
            position: Number.isFinite(pos) && pos > 0 ? pos : 0,
            knownDuration: Number.isFinite(dur) && dur > 0 ? dur : NaN,
            paused: false,
          };
          plexSearch.value = item.title;
          input.value = item.url;
          form.requestSubmit();
        });
        plexHistoryList.appendChild(btn);
      }
    }

    async function loadPlexHistory() {
      if (plexHistoryLoadInFlight) return plexHistoryLoadInFlight;
      plexHistoryLoadInFlight = (async function () {
        try {
          const res = await fetch('./history/plex?t=' + Date.now(), { cache: 'no-store' });
          if (res.ok) {
            const data = await res.json();
            applyPlexHistoryCache(data.results || []);
            plexHistoryLoaded = true;
            return;
          }
        } catch (_) {}
        if (!plexHistoryLoaded) {
          applyPlexHistoryCache([]);
        }
      })();
      try {
        await plexHistoryLoadInFlight;
      } finally {
        plexHistoryLoadInFlight = null;
      }
    }

    async function syncPlexHistoryPull(force) {
      const now = Date.now();
      if (!force && (now - plexSyncLastPullAtMs) < PLEX_SYNC_PULL_INTERVAL_MS) return;
      try {
        const res = await fetch('./history/plex/sync/pull', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: '{}',
          cache: 'no-store',
        });
        if (!res.ok) return;
        plexSyncLastPullAtMs = Date.now();
        await loadPlexHistory();
      } catch (_) {}
    }

    async function flushPlexHistoryUpsert(force) {
      if (plexHistoryUpsertInFlight || !plexHistoryPendingItem) return;
      const now = Date.now();
      if (!force && (now - plexHistoryLastUpsertAtMs) < PLEX_HISTORY_UPSERT_MIN_INTERVAL_MS) return;
      const nextItem = plexHistoryPendingItem;
      plexHistoryPendingItem = null;
      plexHistoryUpsertInFlight = true;
      try {
        const res = await fetch('./history/plex/upsert', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(nextItem),
        });
        if (res.ok) {
          plexHistoryLastUpsertAtMs = Date.now();
          const data = await res.json();
          if (data && data.item) {
            const updated = sanitizePlexHistoryItem(data.item);
            if (updated) {
              const idx = plexHistoryCache.findIndex(function (item) { return item.url === updated.url; });
              if (idx >= 0) {
                plexHistoryCache[idx] = { ...plexHistoryCache[idx], ...updated };
              } else {
                plexHistoryCache.unshift(updated);
              }
              applyPlexHistoryCache(plexHistoryCache);
            }
          }
        } else {
          plexHistoryPendingItem = nextItem;
        }
      } catch (_) {
        plexHistoryPendingItem = nextItem;
      } finally {
        plexHistoryUpsertInFlight = false;
      }
      if (plexHistoryPendingItem) {
        setTimeout(function () { flushPlexHistoryUpsert(false); }, 900);
      }
    }

    function buildCurrentPlexSyncPayload(eventName) {
      if (currentIsLiveStream) return null;
      if (!currentPlexMeta || !currentPlexMeta.url || !currentPlexMeta.title) return null;
      const activeUrl = String(currentMediaUrl || input.value || '').trim();
      if (!activeUrl || activeUrl !== currentPlexMeta.url) return null;
      const contentId = String(currentPlexMeta.content_id || '').trim();
      const partId = String(currentPlexMeta.part_id || '').trim() || parsePartIdFromUrl(currentPlexMeta.url);
      if (!contentId && !partId) return null;
      const position = getAbsolutePlaybackTime();
      const duration = Number.isFinite(knownDurationSeconds) && knownDurationSeconds > 0 ? knownDurationSeconds : NaN;
      const payload = {
        content_id: contentId,
        part_id: partId,
        url: currentPlexMeta.url,
        title: currentPlexMeta.title,
        type: currentPlexMeta.type || 'item',
        position: Number.isFinite(position) && position > 0 ? position : 0,
        known_duration: Number.isFinite(duration) && duration > 0 ? duration : null,
        state: buildPlexSyncState(eventName),
        event: String(eventName || ''),
        mark_watched: shouldMarkWatched(position, duration),
        updated_at: Date.now(),
      };
      return payload;
    }

    async function flushPlexSyncPush(force) {
      if (plexSyncPushInFlight || !plexSyncPendingPayload) return;
      const now = Date.now();
      if (!force && (now - plexSyncLastPushAtMs) < PLEX_SYNC_PUSH_INTERVAL_MS) return;
      const payload = plexSyncPendingPayload;
      plexSyncPendingPayload = null;
      plexSyncPushInFlight = true;
      try {
        const res = await fetch('./history/plex/sync/push', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (res.ok) {
          plexSyncLastPushAtMs = Date.now();
        } else {
          plexSyncPendingPayload = payload;
        }
      } catch (_) {
        plexSyncPendingPayload = payload;
      } finally {
        plexSyncPushInFlight = false;
      }
      if (plexSyncPendingPayload) {
        setTimeout(function () { flushPlexSyncPush(false); }, 1200);
      }
    }

    function queuePlexSyncPush(eventName, force) {
      const payload = buildCurrentPlexSyncPayload(eventName);
      if (!payload) return;
      plexSyncPendingPayload = payload;
      void flushPlexSyncPush(!!force);
    }

    async function deletePlexHistoryItem(url) {
      const target = String(url || '').trim();
      if (!target) return;
      const previous = plexHistoryCache.slice();
      applyPlexHistoryCache(previous.filter(function (item) { return item.url !== target; }));
      try {
        const res = await fetch('./history/plex/delete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url: target }),
        });
        if (!res.ok) applyPlexHistoryCache(previous);
      } catch (_) {
        applyPlexHistoryCache(previous);
      }
    }

    function upsertCurrentPlexHistory(force) {
      if (currentIsLiveStream) return;
      if (!currentPlexMeta || !currentPlexMeta.url || !currentPlexMeta.title) return;
      const activeUrl = String(currentMediaUrl || input.value || '').trim();
      if (!activeUrl || activeUrl !== currentPlexMeta.url) return;
      const position = getAbsolutePlaybackTime();
      const nextEntry = {
        url: currentPlexMeta.url,
        title: currentPlexMeta.title,
        type: currentPlexMeta.type || 'item',
        position: Number.isFinite(position) && position > 0 ? position : 0,
        known_duration: Number.isFinite(knownDurationSeconds) && knownDurationSeconds > 0 ? knownDurationSeconds : null,
        updated_at: Date.now(),
        content_id: String(currentPlexMeta.content_id || ''),
        part_id: String(currentPlexMeta.part_id || parsePartIdFromUrl(currentPlexMeta.url)),
        source: 'splay',
      };
      const list = normalizePlexHistoryList(plexHistoryCache);
      const idx = list.findIndex(function (item) { return item.url === nextEntry.url; });
      if (idx >= 0) {
        list[idx] = { ...list[idx], ...nextEntry };
      } else {
        list.unshift(nextEntry);
      }
      applyPlexHistoryCache(list);
      plexHistoryPendingItem = nextEntry;
      void flushPlexHistoryUpsert(!!force);
    }

    function renderChannelsList(items) {
      channelsList.innerHTML = '';
      if (!items.length) {
        const empty = document.createElement('div');
        empty.className = 'plex-history-empty';
        empty.textContent = 'No channels found.';
        channelsList.appendChild(empty);
        return;
      }
      for (const channel of items) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'channel-item';
        const title = channel.name || channel.group || channel.url;
        btn.title = title;
        btn.setAttribute('aria-label', title);

        if (channel.logo) {
          const logo = document.createElement('img');
          logo.className = 'channel-logo';
          logo.loading = 'lazy';
          logo.decoding = 'async';
          logo.referrerPolicy = 'no-referrer';
          logo.alt = title;
          logo.src = './channels/logo?url=' + encodeURIComponent(channel.logo);
          logo.onerror = function () {
            logo.replaceWith(buildChannelFallback(title));
          };
          btn.appendChild(logo);
        } else {
          btn.appendChild(buildChannelFallback(title));
        }

        btn.addEventListener('click', function () {
          input.value = channel.url;
          closeChannelsModal();
          form.requestSubmit();
        });
        channelsList.appendChild(btn);
      }
    }

    function buildChannelFallback(title) {
      const fallback = document.createElement('div');
      fallback.className = 'channel-logo-fallback';
      fallback.textContent = title;
      return fallback;
    }

    function filterChannels(query) {
      const q = String(query || '').trim().toLowerCase();
      if (!q) return channelsCatalog.slice();
      return channelsCatalog.filter(function (item) {
        return String(item.name || '').toLowerCase().includes(q)
          || String(item.group || '').toLowerCase().includes(q)
          || String(item.url || '').toLowerCase().includes(q);
      });
    }

    async function openChannelsModal() {
      channelsModal.classList.add('show');
      channelsList.innerHTML = '<div class="channel-meta">Loading channels...</div>';
      try {
        const res = await fetch('./channels/list', { cache: 'no-store' });
        if (!res.ok) throw new Error('channels fetch failed');
        const data = await res.json();
        channelsCatalog = Array.isArray(data.results) ? data.results : [];
        renderChannelsList(filterChannels(channelsSearch.value));
      } catch (_) {
        channelsList.innerHTML = '<div class="plex-history-empty">Could not load remote M3U channels source</div>';
      }
    }

    function clearOverlayTimer() {
      if (overlayFadeTimer) {
        clearTimeout(overlayFadeTimer);
        overlayFadeTimer = null;
      }
    }

    function clearControlsHideTimer() {
      if (controlsHideTimer) {
        clearTimeout(controlsHideTimer);
        controlsHideTimer = null;
      }
    }

    function showPlayerControls() {
      playerControls.classList.add('show');
      clearControlsHideTimer();
      if (!isPaused) {
        controlsHideTimer = setTimeout(function () {
          playerControls.classList.remove('show');
        }, 2200);
      }
    }

    function hidePlayerControlsSoon(delayMs) {
      clearControlsHideTimer();
      if (isPaused) return;
      controlsHideTimer = setTimeout(function () {
        playerControls.classList.remove('show');
      }, Number.isFinite(delayMs) ? delayMs : 1400);
    }

    function showLoadingSpinner() {
      loadingOverlay.classList.add('show');
    }

    function hideLoadingSpinner() {
      loadingOverlay.classList.remove('show');
    }

    function renderOffsetValue() {}

    function updatePlayPauseUi() {
      overlayPlayPauseIcon.src = isPaused ? './play.png' : './pause.png';
      overlayPlayPauseBtn.setAttribute('aria-label', isPaused ? 'Play' : 'Pause');
      if (isPaused && activeSessionId) {
        showOverlay('â–¶', true, true);
      } else {
        screenOverlay.classList.remove('show', 'fade', 'clickable');
        overlayIcon.classList.remove('clickable');
      }
    }

    function setMuted(muted) {
      const nextMuted = !!muted;
      audio.muted = nextMuted;
      liveMasterVideo.muted = nextMuted;
      muteBtn.classList.toggle('is-muted', nextMuted);
      muteBtn.setAttribute('aria-label', nextMuted ? 'Unmute audio' : 'Mute audio');
    }

    function updateLiveStartAudioButton() {}

    function formatClock(seconds) {
      if (!Number.isFinite(seconds) || seconds < 0) return '--:--';
      const total = Math.floor(seconds);
      const h = Math.floor(total / 3600);
      const m = Math.floor((total % 3600) / 60);
      const s = total % 60;
      if (h > 0) {
        return String(h) + ':' + String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
      }
      return String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
    }

    function refreshSeekUi() {
      const media = currentIsLiveStream ? getLiveTimingMedia() : audio;
      const relativeCurrent = Number.isFinite(media.currentTime) ? media.currentTime : 0;
      const current = currentIsLiveStream ? relativeCurrent : (mediaBaseTime + relativeCurrent);
      const duration = Number.isFinite(media.duration) ? media.duration : NaN;
      if (!currentIsLiveStream) {
        const effectiveDuration = (Number.isFinite(knownDurationSeconds) && knownDurationSeconds > 0)
          ? knownDurationSeconds
          : duration;
        const hasDuration = Number.isFinite(effectiveDuration) && effectiveDuration > 0;
        if (hasDuration) {
          seekRangeMax = Math.max(1, effectiveDuration);
        } else {
          // When browser cannot determine duration from streamed audio,
          // keep a growing timeline so seeking still works.
          seekRangeMax = Math.max(seekRangeMax, current + 30);
        }
        seekBar.disabled = false;
        seekBar.max = String(seekRangeMax);
        if (!isSeeking) {
          seekBar.value = String(Math.max(0, Math.min(seekRangeMax, current)));
        }
        timeLabel.textContent = formatClock(current) + ' / ' + (hasDuration ? formatClock(effectiveDuration) : '--:--');
        return;
      }

      seekBar.disabled = true;
      seekBar.max = '100';
      if (!isSeeking) seekBar.value = '0';
      timeLabel.textContent = formatClock(current) + ' / Live';
    }

    function showOverlay(icon, persistent, clickable) {
      clearOverlayTimer();
      overlayIcon.textContent = icon;
      overlayIcon.classList.toggle('clickable', !!clickable);
      screenOverlay.classList.toggle('clickable', !!clickable);
      screenOverlay.classList.remove('fade');
      screenOverlay.classList.add('show');
      if (!persistent) {
        screenOverlay.classList.add('fade');
        overlayFadeTimer = setTimeout(function () {
          screenOverlay.classList.remove('show', 'fade', 'clickable');
          overlayIcon.classList.remove('clickable');
        }, 780);
      }
    }

    async function loadPlexItem(item) {
      try {
        statusEl.style.display = 'block';
        statusEl.textContent = 'Resolving Plex item...';
        const res = await fetch('./plex/load?id=' + encodeURIComponent(item.content_id) + '&type=' + encodeURIComponent(item.type), { cache: 'no-store' });
        if (!res.ok) throw new Error('plex load failed');
        const data = await res.json();
        if (!data.url) throw new Error('missing media url');
        currentPlexMeta = {
          url: data.url,
          title: String(data.title || item.title || 'Plex Item'),
          type: String(item.type || 'item'),
          content_id: String(data.content_id || item.content_id || ''),
          part_id: String(data.part_id || parsePartIdFromUrl(data.url)),
        };
        const plexStart = Number(data.start_position);
        const plexDuration = Number(data.known_duration);
        restoreResumeState = {
          url: data.url,
          position: Number.isFinite(plexStart) && plexStart > 0 ? plexStart : 0,
          knownDuration: Number.isFinite(plexDuration) && plexDuration > 0 ? plexDuration : NaN,
          paused: false,
        };
        input.value = data.url;
        if (data.title) {
          plexSearch.value = data.title;
        }
        hidePlexSuggestions();
        hidePlexBrowser();
        form.requestSubmit();
      } catch (_) {
        statusEl.style.display = 'block';
        statusEl.textContent = 'Could not load Plex item.';
      }
    }

    function renderPlexBrowser(items, headerText, onClickItem, backHandler) {
      plexBrowser.innerHTML = '';
      const header = document.createElement('div');
      header.className = 'plex-header';
      if (backHandler) {
        const backBtn = document.createElement('button');
        backBtn.type = 'button';
        backBtn.className = 'plex-back';
        backBtn.textContent = 'Back';
        backBtn.addEventListener('click', backHandler);
        header.appendChild(backBtn);
      }
      const label = document.createElement('span');
      label.textContent = headerText;
      header.appendChild(label);
      plexBrowser.appendChild(header);

      for (const item of items) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'plex-item';
        const titleNode = document.createElement('span');
        titleNode.textContent = item.title || 'Item';
        btn.appendChild(titleNode);
        btn.addEventListener('click', function () {
          onClickItem(item);
        });
        plexBrowser.appendChild(btn);
      }
      plexBrowser.style.display = 'block';
    }

    async function openPlexSeries(item) {
      try {
        const seasonRes = await fetch('./plex/seasons?id=' + encodeURIComponent(item.content_id), { cache: 'no-store' });
        if (!seasonRes.ok) throw new Error('seasons failed');
        const seasonData = await seasonRes.json();
        const seasons = seasonData.results || [];
        if (!seasons.length) {
          statusEl.style.display = 'block';
          statusEl.textContent = 'No seasons found for that series.';
          return;
        }
        hidePlexSuggestions();
        renderPlexBrowser(
          seasons.map(s => ({ ...s, title: s.title + (s.leaf_count ? ' (' + s.leaf_count + ')' : '') })),
          'Seasons - ' + (item.title || 'Series'),
          async function (season) {
            try {
              const epRes = await fetch('./plex/episodes?id=' + encodeURIComponent(season.id), { cache: 'no-store' });
              if (!epRes.ok) throw new Error('episodes failed');
              const epData = await epRes.json();
              const episodes = (epData.results || []).map(ep => ({ ...ep, type: 'episode', content_id: ep.id }));
              renderPlexBrowser(
                episodes.map(ep => ({ ...ep, title: 'E' + String(ep.index).padStart(2, '0') + ' - ' + ep.title })),
                'Episodes - ' + season.title,
                function (ep) {
                  loadPlexItem(ep);
                },
                function () {
                  openPlexSeries(item);
                }
              );
            } catch (_) {
              statusEl.style.display = 'block';
              statusEl.textContent = 'Could not load episodes.';
            }
          },
          function () {
            hidePlexBrowser();
          }
        );
      } catch (_) {
        statusEl.style.display = 'block';
        statusEl.textContent = 'Could not load seasons.';
      }
    }

    function renderPlexSuggestions(results) {
      if (!results || !results.length) {
        hidePlexSuggestions();
        return;
      }
      plexSuggest.innerHTML = '';
      for (const item of results) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'plex-item';
        const titleNode = document.createElement('span');
        titleNode.textContent = String(item.title || '');
        const typeNode = document.createElement('small');
        const itemType = String(item.type || '');
        const itemTypeLower = itemType.toLowerCase();
        const rawYear = Number(item.year);
        const hasYear = Number.isFinite(rawYear) && rawYear >= 1800 && rawYear <= 3000;
        const showYear = hasYear && (itemTypeLower === 'movie' || itemTypeLower === 'series');
        typeNode.textContent = showYear
          ? '(' + itemType + ' â€¢ ' + String(Math.trunc(rawYear)) + ')'
          : '(' + itemType + ')';
        btn.appendChild(titleNode);
        btn.appendChild(typeNode);
        btn.addEventListener('click', function () {
          if (String(item.type || '').toLowerCase() === 'series') {
            openPlexSeries(item);
            return;
          }
          loadPlexItem(item);
        });
        plexSuggest.appendChild(btn);
      }
      plexSuggest.style.display = 'block';
    }

    function getTargetOffsetSeconds() {
      return 0;
    }

    function nudgeSyncTarget(delta) {
      const next = Math.round((getTargetOffsetSeconds() + delta) * 100) / 100;
      previousSyncTarget = 0;
      manualOffsetEdited = true;
      liveTunerActive = false;
      manualNudgeDirection = Math.sign(delta);
      manualNudgeUntilMs = Date.now() + 1400;
      syncInfo.textContent = 'Sync: manual offset ' + next.toFixed(2) + 's';
    }

    function isLikelyLiveStream(url) {
      const value = String(url || '').toLowerCase();
      return value.includes('/proxy/ts/stream/')
        || value.includes('.m3u8')
        || value.includes('/live/')
        || (value.includes('stream.mpg') && value.includes('format=ts'))
        || value.includes('codec=copy');
    }

    function concatUint8(a, b) {
      if (!a || a.length === 0) return b;
      if (!b || b.length === 0) return a;
      const out = new Uint8Array(a.length + b.length);
      out.set(a, 0);
      out.set(b, a.length);
      return out;
    }

    function findStartCodes(buffer) {
      const out = [];
      for (let i = 0; i < buffer.length - 3; i += 1) {
        if (buffer[i] === 0 && buffer[i + 1] === 0) {
          if (buffer[i + 2] === 1) {
            out.push({ index: i, len: 3 });
            i += 2;
            continue;
          }
          if (buffer[i + 2] === 0 && buffer[i + 3] === 1) {
            out.push({ index: i, len: 4 });
            i += 3;
          }
        }
      }
      return out;
    }

    function createAnnexBParser() {
      let buffer = new Uint8Array(0);
      return {
        push(chunk, flush) {
          buffer = concatUint8(buffer, chunk || new Uint8Array(0));
          const starts = findStartCodes(buffer);
          if (!starts.length) {
            if (flush) {
              buffer = new Uint8Array(0);
            }
            return [];
          }
          const nalus = [];
          const firstStart = starts[0].index;
          if (firstStart > 0) {
            buffer = buffer.slice(firstStart);
            for (let i = 0; i < starts.length; i += 1) starts[i].index -= firstStart;
          }
          for (let i = 0; i < starts.length - 1; i += 1) {
            const begin = starts[i].index + starts[i].len;
            const end = starts[i + 1].index;
            if (end > begin) nalus.push(buffer.slice(begin, end));
          }
          if (flush) {
            const last = starts[starts.length - 1];
            const begin = last.index + last.len;
            if (buffer.length > begin) nalus.push(buffer.slice(begin));
            buffer = new Uint8Array(0);
          } else {
            buffer = buffer.slice(starts[starts.length - 1].index);
          }
          return nalus;
        }
      };
    }

    function h264RbspFromPayload(payload) {
      const out = [];
      for (let i = 0; i < payload.length; i += 1) {
        if (i >= 2 && payload[i] === 0x03 && payload[i - 1] === 0x00 && payload[i - 2] === 0x00) {
          continue;
        }
        out.push(payload[i]);
      }
      return new Uint8Array(out);
    }

    function readUeGolomb(rbsp, bitState) {
      let leadingZeroBits = 0;
      while (true) {
        if (bitState.index >= rbsp.length * 8) return null;
        const byte = rbsp[bitState.index >> 3];
        const bit = (byte >> (7 - (bitState.index & 7))) & 1;
        bitState.index += 1;
        if (bit === 0) {
          leadingZeroBits += 1;
        } else {
          break;
        }
      }
      let value = 1;
      for (let i = 0; i < leadingZeroBits; i += 1) {
        if (bitState.index >= rbsp.length * 8) return null;
        const byte = rbsp[bitState.index >> 3];
        const bit = (byte >> (7 - (bitState.index & 7))) & 1;
        bitState.index += 1;
        value = (value << 1) | bit;
      }
      return value - 1;
    }

    function isFirstSliceInPicture(nalu) {
      const naluType = nalu[0] & 0x1f;
      if (naluType < 1 || naluType > 5 || nalu.length < 2) return false;
      const rbsp = h264RbspFromPayload(nalu.subarray(1));
      const bitState = { index: 0 };
      const firstMbInSlice = readUeGolomb(rbsp, bitState);
      return firstMbInSlice === 0;
    }

    function stopWebCodecsVideo(clearCanvas) {
      wcJobToken += 1;
      if (wcFetchAbort) {
        try { wcFetchAbort.abort(); } catch (_) {}
      }
      wcFetchAbort = null;
      if (wcRenderRaf) {
        cancelAnimationFrame(wcRenderRaf);
        wcRenderRaf = 0;
      }
      for (const item of wcFrameQueue) {
        try { item.frame.close(); } catch (_) {}
      }
      wcFrameQueue = [];
      if (wcDecoder) {
        try { wcDecoder.close(); } catch (_) {}
      }
      wcDecoder = null;
      wcDecodeDone = false;
      wcDecodedCount = 0;
      wcRenderedCount = 0;
      resetRealtimeFps();
      if (clearCanvas !== false) {
        streamCanvas.style.display = 'none';
      }
    }

    function h264CodecFromSps(sps) {
      if (!sps || sps.length < 4) return 'avc1.42e01e';
      const b1 = sps[1].toString(16).padStart(2, '0');
      const b2 = sps[2].toString(16).padStart(2, '0');
      const b3 = sps[3].toString(16).padStart(2, '0');
      return 'avc1.' + b1 + b2 + b3;
    }

    function findSpsNalu(nalus) {
      for (const nalu of nalus) {
        if ((nalu[0] & 0x1f) === 7) return nalu;
      }
      return null;
    }

    async function startWebCodecsVideo(startSeconds, settings) {
      if (!window.VideoDecoder) {
        throw new Error('WebCodecs VideoDecoder is not supported in this browser');
      }
      stopWebCodecsVideo(false);
      const token = ++wcJobToken;
      const stamp = Date.now();
      const start = Math.max(0, Number.isFinite(startSeconds) ? startSeconds : 0);
      // Server-side /h264 is normalized to 30fps; keep decoder timeline aligned.
      const fps = TARGET_VIDEO_FPS;
      const url = './h264?sid=' + encodeURIComponent(activeSessionId)
        + '&start=' + start.toFixed(3)
        + '&fps=' + fps
        + '&h264_q=' + settings.h264Q
        + '&t=' + stamp;
      wcFetchAbort = new AbortController();
      stream.src = '';
      stream.style.display = 'none';
      streamCanvas.style.display = 'block';
      if (!wcCanvasCtx) {
        wcCanvasCtx = streamCanvas.getContext('2d', { alpha: false });
      }
      streamCanvas.width = 1280;
      streamCanvas.height = 720;
      wcFrameQueue = [];
      wcDecodedCount = 0;
      wcRenderedCount = 0;
      wcDecodeDone = false;
      let clockBaseTsSec = null;
      let clockBasePerfSec = 0;
      let sawVideoFrame = false;
      let timestampUs = 0;
      const fixedFrameDurationUs = Math.round(1000000 / Math.max(1, fps));
      let configured = false;
      let sawKeyFrame = false;
      const pendingAccessUnits = [];
      let currentAccessUnit = [];
      let sawVclInAccessUnit = false;

      const response = await fetch(url, { cache: 'no-store', signal: wcFetchAbort.signal });
      if (!response.ok) {
        throw new Error('H.264 stream HTTP ' + response.status);
      }
      if (!response.body || !response.body.getReader) {
        throw new Error('Readable stream body is not supported');
      }
      const reader = response.body.getReader();

      function getMasterTimeSec() {
        if (currentIsLiveStream) {
          const media = getLiveTimingMedia();
          if (media && !media.paused && Number.isFinite(media.currentTime)) {
            return media.currentTime;
          }
        } else if (audio && !audio.paused && Number.isFinite(audio.currentTime)) {
          return audio.currentTime;
        }
        if (clockBaseTsSec === null) return 0;
        return clockBaseTsSec + ((performance.now() - clockBasePerfSec) / 1000);
      }

      function onFrameRendered(renderedTsSec) {
        const frameNow = performance.now();
        markPresentedVideoFrame(renderedTsSec);
        noteRenderedFrame();
        if (currentIsLiveStream) {
          liveFrameLoadCount += 1;
          if (!liveFirstFrameLoadAtMs) liveFirstFrameLoadAtMs = frameNow;
          liveLastFrameLoadAtMs = frameNow;
        }
        hasVideoFrame = true;
        liveFirstFrameAtMs = frameNow;
        if (!sawVideoFrame) {
          sawVideoFrame = true;
          clearLiveFirstFrameRetry();
          liveFirstFrameRetries = 0;
          hideLoadingSpinner();
          statusEl.style.display = 'none';
          streamCanvas.style.display = 'block';
          if (freezeOnNextFrame) {
            freezeOnNextFrame = false;
            freezeCurrentVideoFrame();
            return;
          }
          updateLiveStartAudioButton();
          if (!isPaused && pendingAudioStart) {
            if (currentIsLiveStream) {
              maybeStartPendingLiveAudio().catch(function () {});
            } else {
              pendingAudioStart = false;
              attemptAudioPlay();
            }
          }
        }
      }

      function renderFrames() {
        if (token !== wcJobToken || !wcCanvasCtx) return;
        const masterTimeRaw = getMasterTimeSec();
        const masterTime = masterTimeRaw - WC_AUDIO_MASTER_RENDER_LAG_SEC;
        const dueTime = masterTime + WC_AUDIO_MASTER_RENDER_EARLY_SEC;
        // Keep video pinned to audio by dropping clearly late frames.
        while (
          wcFrameQueue.length > WC_AUDIO_MASTER_DROP_MIN_QUEUE
          && wcFrameQueue[1].timestampSec <= masterTime - WC_AUDIO_MASTER_DROP_LATE_SEC
        ) {
          const drop = wcFrameQueue.shift();
          drop.frame.close();
        }
        // If multiple frames are already due, keep only the newest due frame for smoother cadence.
        while (wcFrameQueue.length > 1 && wcFrameQueue[1].timestampSec <= dueTime) {
          const stale = wcFrameQueue.shift();
          stale.frame.close();
        }
        if (wcFrameQueue.length && wcFrameQueue[0].timestampSec <= dueTime) {
          const item = wcFrameQueue.shift();
          if (streamCanvas.width !== item.frame.displayWidth || streamCanvas.height !== item.frame.displayHeight) {
            streamCanvas.width = item.frame.displayWidth;
            streamCanvas.height = item.frame.displayHeight;
          }
          wcCanvasCtx.drawImage(item.frame, 0, 0, streamCanvas.width, streamCanvas.height);
          item.frame.close();
          wcRenderedCount += 1;
          onFrameRendered(item.timestampSec);
        }
        if (wcDecodeDone && wcFrameQueue.length === 0) {
          syncInfo.textContent = 'Sync: video stream complete';
          return;
        }
        wcRenderRaf = requestAnimationFrame(renderFrames);
      }
      wcRenderRaf = requestAnimationFrame(renderFrames);

      wcDecoder = new window.VideoDecoder({
        output: (frame) => {
          if (token !== wcJobToken) {
            frame.close();
            return;
          }
          const tsUs = Number.isFinite(frame.timestamp) ? frame.timestamp : timestampUs;
          const tsSec = tsUs / 1000000;
          if (clockBaseTsSec === null) {
            clockBaseTsSec = tsSec;
            clockBasePerfSec = performance.now();
          }
          wcFrameQueue.push({ frame, timestampSec: tsSec });
          if (wcFrameQueue.length > wcFrameQueueMax * 2) {
            const drop = wcFrameQueue.shift();
            drop.frame.close();
          }
        },
        error: (error) => {
          if (token !== wcJobToken) return;
          hideLoadingSpinner();
          statusEl.style.display = 'block';
          statusEl.textContent = 'WebCodecs decode error: ' + (error && error.message ? error.message : String(error));
        }
      });

      async function ensureConfiguredFromSps(sps) {
        if (configured) return;
        const codec = h264CodecFromSps(sps);
        const support = await window.VideoDecoder.isConfigSupported({
          codec,
          optimizeForLatency: true,
          hardwareAcceleration: 'prefer-hardware',
          avc: { format: 'annexb' }
        });
        if (!support.supported) {
          throw new Error('H.264 codec not supported: ' + codec);
        }
        wcDecoder.configure(support.config);
        configured = true;
      }

      function decodeAccessUnit(nalus) {
        if (!configured || !wcDecoder || token !== wcJobToken || !nalus.length) return;
        const isKey = nalus.some((nalu) => (nalu[0] & 0x1f) === 5);
        if (!sawKeyFrame && !isKey) return;
        if (isKey) sawKeyFrame = true;
        let totalLen = 0;
        for (const nalu of nalus) totalLen += 4 + nalu.length;
        const data = new Uint8Array(totalLen);
        let offset = 0;
        for (const nalu of nalus) {
          data.set([0, 0, 0, 1], offset);
          offset += 4;
          data.set(nalu, offset);
          offset += nalu.length;
        }
        const frameDurationUs = fixedFrameDurationUs;

        wcDecoder.decode(new EncodedVideoChunk({
          type: isKey ? 'key' : 'delta',
          timestamp: timestampUs,
          duration: frameDurationUs,
          data
        }));
        wcDecodedCount += 1;
        timestampUs += frameDurationUs;
      }

      async function processAccessUnit(nalus) {
        if (!nalus.length) return;
        if (!configured) {
          const sps = findSpsNalu(nalus);
          if (sps) {
            await ensureConfiguredFromSps(sps);
            for (const queued of pendingAccessUnits) decodeAccessUnit(queued);
            pendingAccessUnits.length = 0;
          }
        }
        if (!configured) {
          pendingAccessUnits.push(nalus);
          return;
        }
        while (
          token === wcJobToken &&
          wcDecoder &&
          (wcDecoder.decodeQueueSize > 32 || wcFrameQueue.length > wcFrameQueueMax)
        ) {
          await new Promise((resolve) => setTimeout(resolve, 4));
        }
        decodeAccessUnit(nalus);
      }

      async function consumeNalu(nalu) {
        const naluType = nalu[0] & 0x1f;
        if (naluType === 9) {
          await processAccessUnit(currentAccessUnit);
          currentAccessUnit = [];
          sawVclInAccessUnit = false;
          return;
        }
        const isVcl = naluType >= 1 && naluType <= 5;
        if (isVcl && sawVclInAccessUnit && isFirstSliceInPicture(nalu)) {
          await processAccessUnit(currentAccessUnit);
          currentAccessUnit = [];
          sawVclInAccessUnit = false;
        }
        currentAccessUnit.push(nalu);
        if (isVcl) sawVclInAccessUnit = true;
      }

      const parser = createAnnexBParser();
      while (token === wcJobToken) {
        const { done, value } = await reader.read();
        if (done) break;
        const nalus = parser.push(value, false);
        for (const nalu of nalus) {
          await consumeNalu(nalu);
        }
      }
      const tail = parser.push(new Uint8Array(0), true);
      for (const nalu of tail) {
        await consumeNalu(nalu);
      }
      await processAccessUnit(currentAccessUnit);
      if (!configured) {
        throw new Error('No SPS found in H.264 stream');
      }
      await wcDecoder.flush();
      wcDecodeDone = true;
    }

    function setStreamFromTime(seconds) {
      const stamp = Date.now();
      const start = Math.max(0, Number.isFinite(seconds) ? seconds : 0);
      const settings = getVideoSettings();
      currentVideoRenderer = settings.mode;
      resetPresentedVideoClock();
      resetRealtimeFps();
      liveDebugLog('setStreamFromTime', {
        sid: activeSessionId,
        start,
        live: currentIsLiveStream,
        mode: currentVideoRenderer,
        fps: TARGET_VIDEO_FPS,
        q: settings.q,
      });
      if (currentVideoRenderer === 'webcodecs_h264') {
        startWebCodecsVideo(start, settings).catch(function (error) {
          if (String(error && error.name) === 'AbortError') return;
          hideLoadingSpinner();
          statusEl.style.display = 'block';
          statusEl.textContent = 'Could not start H.264 stream: ' + (error && error.message ? error.message : String(error));
          syncInfo.textContent = 'Sync: stream error';
        });
        return;
      }
      stopWebCodecsVideo();
      streamCanvas.style.display = 'none';
      stream.src = './mjpeg?sid=' + encodeURIComponent(activeSessionId)
        + '&start=' + start.toFixed(3)
        + '&fps=' + TARGET_VIDEO_FPS
        + '&q=' + settings.q
        + '&t=' + stamp;
    }

    function setAudioFromTime(seconds) {
      const stamp = Date.now();
      const start = Math.max(0, Number.isFinite(seconds) ? seconds : 0);
      if (currentIsLiveStream) {
        liveTimingMode = 'master';
        liveDebugLog('setAudioFromTime(live)', {
          sid: activeSessionId,
          start,
          mode: 'master',
        });
        liveMasterVideo.src = './audio?sid=' + encodeURIComponent(activeSessionId) + '&start=' + start.toFixed(3) + '&t=' + stamp;
        liveMasterVideo.load();
        audio.pause();
        audio.src = '';
        return;
      }
      audio.src = './audio?sid=' + encodeURIComponent(activeSessionId) + '&start=' + start.toFixed(3) + '&t=' + stamp;
      audio.load();
    }

    function applyCurrentVideoSettings() {
      syncVideoSettingsInputs();
      saveVideoSettings();
      if (!activeSessionId) return;
      currentVideoRenderer = getVideoSettings().mode;
      suppressStreamError = true;
      hasVideoFrame = false;
      lastVideoClock = 0;
      const target = currentIsLiveStream
        ? 0
        : Math.max(0, mediaBaseTime + (Number.isFinite(audio.currentTime) ? audio.currentTime : 0));
      stream.src = '';
      setStreamFromTime(target);
      statusEl.style.display = 'block';
      statusEl.textContent = 'Applying video settings...';
    }

    function captureFrameDataUrl() {
      try {
        if (currentVideoRenderer === 'webcodecs_h264') {
          if (!streamCanvas.width || !streamCanvas.height) return '';
          return streamCanvas.toDataURL('image/jpeg', 0.85);
        }
        if (!stream.naturalWidth || !stream.naturalHeight) return '';
        const canvas = document.createElement('canvas');
        canvas.width = stream.naturalWidth;
        canvas.height = stream.naturalHeight;
        const ctx = canvas.getContext('2d');
        if (!ctx) return '';
        ctx.drawImage(stream, 0, 0, canvas.width, canvas.height);
        return canvas.toDataURL('image/jpeg', 0.85);
      } catch (_) {
        return '';
      }
    }

    function freezeCurrentVideoFrame() {
      pausedFrameDataUrl = captureFrameDataUrl();
      suppressStreamError = true;
      if (currentVideoRenderer === 'webcodecs_h264') {
        stopWebCodecsVideo(false);
        stream.src = '';
        stream.style.display = 'none';
        streamCanvas.style.display = 'block';
      } else if (pausedFrameDataUrl) {
        stream.src = pausedFrameDataUrl;
        stream.style.display = 'block';
      } else {
        stream.src = '';
      }
      audio.pause();
      audio.playbackRate = 1.0;
      updatePlayPauseUi();
      refreshSeekUi();
      showPlayerControls();
    }

    function clearLiveVideoHoldTimer() {
      if (liveVideoHoldTimer) {
        clearTimeout(liveVideoHoldTimer);
        liveVideoHoldTimer = null;
      }
    }

    function clearLiveAudioHoldTimer() {
      if (liveAudioHoldTimer) {
        clearTimeout(liveAudioHoldTimer);
        liveAudioHoldTimer = null;
      }
    }

    function startLiveVideoHold(errorSeconds) {
      if (!currentIsLiveStream || !LIVE_USE_VIDEO_HOLD_CATCHUP || liveVideoHoldActive) return false;
      const behindBy = Math.max(0, -errorSeconds);
      if (behindBy < LIVE_VIDEO_HOLD_TRIGGER_SECONDS) return false;
      const holdMs = Math.max(LIVE_VIDEO_HOLD_MIN_MS, Math.min(LIVE_VIDEO_HOLD_MAX_MS, behindBy * 1000));
      const frame = captureFrameDataUrl();
      if (!frame) return false;
      suppressStreamError = true;
      stream.src = frame;
      stream.style.display = 'block';
      liveVideoHoldActive = true;
      liveVideoHoldUntilMs = performance.now() + holdMs;
      clearLiveVideoHoldTimer();
      liveVideoHoldTimer = setTimeout(function () {
        liveVideoHoldTimer = null;
        releaseLiveVideoHold();
      }, holdMs + 20);
      syncInfo.textContent = 'Sync: holding video ' + (holdMs / 1000).toFixed(2) + 's to catch audio';
      liveDebugLog('video hold start', { errorSeconds, holdMs });
      return true;
    }

    function releaseLiveVideoHold() {
      if (!liveVideoHoldActive || !currentIsLiveStream || !activeSessionId) return;
      clearLiveVideoHoldTimer();
      liveVideoHoldActive = false;
      liveVideoHoldUntilMs = 0;
      liveHoldCooldownUntilMs = performance.now() + LIVE_HOLD_COOLDOWN_MS;
      suppressStreamError = true;
      setStreamFromTime(0);
      syncInfo.textContent = 'Sync: resuming live video';
      liveDebugLog('video hold release', {});
    }

    function startLiveAudioHold(errorSeconds, media) {
      if (!currentIsLiveStream || liveAudioHoldActive) return false;
      const aheadBy = Math.max(0, errorSeconds);
      if (aheadBy < LIVE_AUDIO_HOLD_TRIGGER_SECONDS) return false;
      const holdMs = Math.max(LIVE_AUDIO_HOLD_MIN_MS, Math.min(LIVE_AUDIO_HOLD_MAX_MS, aheadBy * 1000));
      liveAudioHoldActive = true;
      clearLiveAudioHoldTimer();
      try {
        media.pause();
      } catch (_) {}
      liveAudioHoldTimer = setTimeout(async function () {
        liveAudioHoldTimer = null;
        if (!liveAudioHoldActive) return;
        liveAudioHoldActive = false;
        liveHoldCooldownUntilMs = performance.now() + LIVE_HOLD_COOLDOWN_MS;
        if (!isPaused) {
          try {
            await media.play();
          } catch (_) {}
        }
        liveDebugLog('audio hold release', { holdMs });
      }, holdMs + 20);
      syncInfo.textContent = 'Sync: holding audio ' + (holdMs / 1000).toFixed(2) + 's to catch video';
      liveDebugLog('audio hold start', { errorSeconds, holdMs });
      return true;
    }

    function applySyncCorrection(clockPayload) {
      const media = currentIsLiveStream ? getLiveTimingMedia() : audio;
      let videoClock = NaN;
      if (clockPayload && typeof clockPayload === 'object') {
        videoClock = Number(clockPayload.video_clock);
        const videoRaw = Number(clockPayload.video_raw_clock);
        const audioRaw = Number(clockPayload.audio_raw_clock);
        const audioOriginRaw = Number(clockPayload.audio_origin_raw);
        if (Number.isFinite(videoRaw)) {
          lastVideoRawClock = videoRaw;
        }
        if (Number.isFinite(audioRaw)) {
          lastAudioRawClock = audioRaw;
        }
        if (Number.isFinite(audioOriginRaw)) {
          liveAudioOriginRawClock = audioOriginRaw;
        }
      } else {
        videoClock = Number(clockPayload);
      }
      if (Number.isFinite(videoClock)) {
        lastVideoClock = videoClock;
      }
      if (media.paused || !Number.isFinite(media.currentTime) || media.readyState < 2) {
        return;
      }
      const presentedVideoClock = Number.isFinite(lastPresentedVideoClock)
        ? lastPresentedVideoClock
        : videoClock;
      if (!Number.isFinite(presentedVideoClock)) {
        return;
      }
      const drift = media.currentTime - presentedVideoClock;
      const nowMs = performance.now();
      const frameAgeSec = lastPresentedVideoAtMs
        ? Math.max(0, (nowMs - lastPresentedVideoAtMs) / 1000)
        : NaN;
      let sourceDrift = NaN;
      const useSourceDrift = currentIsLiveStream
        && liveTimingMode === 'master'
        && Number.isFinite(lastVideoRawClock)
        && Number.isFinite(liveAudioOriginRawClock);
      if (useSourceDrift) {
        const audioSourceNow = liveAudioOriginRawClock + media.currentTime;
        sourceDrift = audioSourceNow - lastVideoRawClock;
      }
      if (currentIsLiveStream && Number.isFinite(lastVideoRawClock) && Number.isFinite(lastAudioRawClock)) {
        const rawGap = lastVideoRawClock - lastAudioRawClock;
        if (Number.isFinite(rawGap) && rawGap >= 0 && rawGap < 20) {
          const clampedGap = Math.max(0, Math.min(LIVE_PIPELINE_GAP_MAX, rawGap));
          livePipelineGapEstimate = (livePipelineGapEstimate * (1 - LIVE_PIPELINE_GAP_ALPHA)) + (clampedGap * LIVE_PIPELINE_GAP_ALPHA);
        }
      }
      if (currentIsLiveStream && liveTunerActive && !liveTunerApplied && !manualOffsetEdited) {
        const now = Date.now();
        if (now - liveTunerStartAt <= LIVE_TUNER_WINDOW_MS) {
          if (Number.isFinite(drift) && Math.abs(drift) < 30) {
            liveTunerSamples.push(drift);
          }
          if (liveTunerSamples.length >= LIVE_TUNER_MIN_SAMPLES) {
            const sorted = liveTunerSamples.slice().sort((a, b) => a - b);
            const median = sorted[Math.floor(sorted.length / 2)];
            const tuned = Math.max(-LIVE_TUNER_MAX_ABS_TARGET, Math.min(LIVE_TUNER_MAX_ABS_TARGET, median * 0.2));
            previousSyncTarget = tuned;
            liveTunerApplied = true;
            syncInfo.textContent = 'Sync: auto-tuned offset to ' + tuned.toFixed(2) + 's';
          }
        } else {
          liveTunerApplied = true;
        }
      }

      const targetOffset = getTargetOffsetSeconds();
      const effectiveTargetOffset = targetOffset;
      const error = drift - effectiveTargetOffset;
      const absError = Math.abs(error);

      if (AUDIO_MASTER_SYNC_MODE) {
        media.playbackRate = 1.0;
        lastSyncSampleAtMs = nowMs;

        if (currentIsLiveStream && LIVE_USE_VIDEO_HOLD_CATCHUP) {
          if (nowMs < liveHoldCooldownUntilMs) {
            return;
          }
          if (liveVideoHoldActive) {
            if (nowMs >= liveVideoHoldUntilMs) {
              releaseLiveVideoHold();
            }
            return;
          }
          if (liveAudioHoldActive) {
            return;
          }
          if (startLiveVideoHold(error)) {
            return;
          }
        }

        const isWebCodecsH264 = currentVideoRenderer === 'webcodecs_h264';
        const staleFrameLimitSec = isWebCodecsH264
          ? VIDEO_AUDIO_MASTER_STALE_FRAME_H264_SEC
          : VIDEO_AUDIO_MASTER_STALE_FRAME_SEC;
        const resyncThresholdSec = isWebCodecsH264
          ? VIDEO_AUDIO_MASTER_RESYNC_THRESHOLD_H264_SEC
          : VIDEO_AUDIO_MASTER_RESYNC_THRESHOLD_SEC;
        const resyncCooldownMs = isWebCodecsH264
          ? VIDEO_AUDIO_MASTER_RESYNC_COOLDOWN_H264_MS
          : VIDEO_AUDIO_MASTER_RESYNC_COOLDOWN_MS;
        const staleFrame = Number.isFinite(frameAgeSec) && frameAgeSec > staleFrameLimitSec;
        const shouldResync = isWebCodecsH264
          ? (staleFrame && error > resyncThresholdSec)
          : ((error > resyncThresholdSec) || (staleFrame && error > 0.08));
        if (
          shouldResync
          && activeSessionId
          && (nowMs - lastVideoResyncAtMs) >= resyncCooldownMs
        ) {
          lastVideoResyncAtMs = nowMs;
          suppressStreamError = true;
          hasVideoFrame = false;
          const target = currentIsLiveStream
            ? 0
            : Math.max(0, mediaBaseTime + media.currentTime);
          setStreamFromTime(target);
          syncInfo.textContent = currentIsLiveStream
            ? 'Sync: audio-master resyncing live video...'
            : 'Sync: audio-master resyncing video...';
          return;
        }

        syncInfo.textContent = 'Sync err: ' + error.toFixed(3) + 's'
          + (Number.isFinite(sourceDrift) ? ' (src ' + sourceDrift.toFixed(3) + 's)' : '')
          + ' (timing:audio)'
          + (Number.isFinite(frameAgeSec) ? ' | frame ' + frameAgeSec.toFixed(2) + 's old' : '');
        return;
      }

      const dt = lastSyncSampleAtMs
        ? Math.max(0.05, Math.min(0.6, (nowMs - lastSyncSampleAtMs) / 1000))
        : 0.2;
      lastSyncSampleAtMs = nowMs;

      if (!currentIsLiveStream && currentSessionMode === 'buffered_live') {
        const nowWall = Date.now();
        const canHardAlign = (nowWall - lastLiveHardSyncAtMs) >= LIVE_HARD_SYNC_COOLDOWN_MS;
        if (absError >= 0.9 && canHardAlign) {
          const step = Math.max(-LIVE_HARD_SYNC_MAX_STEP, Math.min(LIVE_HARD_SYNC_MAX_STEP, -error));
          if (Math.abs(step) > 0.25) {
            try {
              media.currentTime = Math.max(0, media.currentTime + step);
              lastLiveHardSyncAtMs = nowWall;
              syncFilteredError = 0;
              syncIntegralError = 0;
              media.playbackRate = 1.0;
              syncInfo.textContent = 'Sync: buffered align ' + step.toFixed(2) + 's';
              return;
            } catch (_) {}
          }
        }
        media.playbackRate = 1.0;
      }

      if (currentIsLiveStream && error > 0 && absError >= LIVE_HARD_SYNC_THRESHOLD) {
        const nowWall = Date.now();
        if ((nowWall - lastLiveHardSyncAtMs) >= LIVE_HARD_SYNC_COOLDOWN_MS) {
          const step = Math.max(-LIVE_HARD_SYNC_MAX_STEP, Math.min(LIVE_HARD_SYNC_MAX_STEP, -error));
          if (Math.abs(step) > 0.2) {
            try {
              media.currentTime = Math.max(0, media.currentTime + step);
              lastLiveHardSyncAtMs = nowWall;
              syncFilteredError = 0;
              syncIntegralError = 0;
              syncInfo.textContent = 'Sync: hard align ' + step.toFixed(2) + 's';
              return;
            } catch (_) {}
          }
        }
      }

      if (currentIsLiveStream && LIVE_USE_VIDEO_HOLD_CATCHUP) {
        if (nowMs < liveHoldCooldownUntilMs) {
          media.playbackRate = 1.0;
          return;
        }
        if (liveVideoHoldActive) {
          media.playbackRate = 1.0;
          if (nowMs >= liveVideoHoldUntilMs) {
            releaseLiveVideoHold();
          }
          return;
        }
        if (liveAudioHoldActive) {
          media.playbackRate = 1.0;
          return;
        }
        if (startLiveVideoHold(error)) {
          media.playbackRate = 1.0;
          return;
        }
      }

      if (LIVE_ALLOW_EDGE_SNAP && currentIsLiveStream) {
        const now = Date.now();
        const edgeCooldownPassed = (now - lastLiveEdgeSnapAtMs) >= LIVE_AUDIO_EDGE_SNAP_COOLDOWN_MS;
        if (edgeCooldownPassed) {
          const bufferedEnd = getBufferedEndSeconds();
          if (Number.isFinite(bufferedEnd)) {
            const bufferedLag = bufferedEnd - media.currentTime;
            if (Number.isFinite(bufferedLag) && bufferedLag > LIVE_AUDIO_EDGE_LAG_THRESHOLD) {
              const targetEdge = Math.max(0, bufferedEnd - LIVE_STARTUP_BUFFER_SLACK);
              if (targetEdge > media.currentTime + 0.25) {
                const step = targetEdge - media.currentTime;
                try {
                  media.currentTime = targetEdge;
                  lastLiveEdgeSnapAtMs = now;
                  syncFilteredError = 0;
                  syncIntegralError = 0;
                  syncInfo.textContent = 'Sync: edge snap +' + step.toFixed(2) + 's';
                  return;
                } catch (_) {}
              }
            }
          }
        }
      }

      if (LIVE_ALLOW_LARGE_SEEK_CORRECTIONS && currentIsLiveStream && absError > LIVE_LARGE_DRIFT_CORRECTION_THRESHOLD) {
        const cooldownPassed = (Date.now() - lastLargeDriftCorrectionAtMs) >= LIVE_LARGE_DRIFT_CORRECTION_COOLDOWN_MS;
        if (cooldownPassed) {
          const step = Math.max(
            -LIVE_LARGE_DRIFT_CORRECTION_MAX_STEP,
            Math.min(LIVE_LARGE_DRIFT_CORRECTION_MAX_STEP, -error)
          );
          if (Math.abs(step) > 0.35) {
            try {
              media.currentTime = Math.max(0, media.currentTime + step);
              lastLargeDriftCorrectionAtMs = Date.now();
              syncFilteredError = 0;
              syncIntegralError = 0;
              syncInfo.textContent = 'Sync: large drift correction ' + step.toFixed(2) + 's';
              return;
            } catch (_) {
              // Fall back to playback-rate-only correction.
            }
          }
        }
      }

      if (LIVE_ALLOW_BUFFERED_CATCHUP && currentIsLiveStream && error < -LIVE_BUFFERED_CATCHUP_THRESHOLD) {
        const now = Date.now();
        const cooldownPassed = (now - lastLiveBufferedCatchupAtMs) >= LIVE_BUFFERED_CATCHUP_COOLDOWN_MS;
        if (cooldownPassed) {
          const bufferedEnd = getBufferedEndSeconds();
          if (Number.isFinite(bufferedEnd)) {
            const latestSafe = Math.max(0, bufferedEnd - LIVE_STARTUP_BUFFER_SLACK);
            const availableAdvance = latestSafe - media.currentTime;
            if (availableAdvance > 0.45) {
              const desired = Math.min(LIVE_BUFFERED_CATCHUP_MAX_STEP, -error);
              const step = Math.max(0, Math.min(desired, availableAdvance));
              if (step > 0.4) {
                try {
                  media.currentTime = Math.max(0, media.currentTime + step);
                  lastLiveBufferedCatchupAtMs = now;
                  syncFilteredError = 0;
                  syncIntegralError = 0;
                  syncInfo.textContent = 'Sync: live catch-up +' + step.toFixed(2) + 's';
                  return;
                } catch (_) {
                  // Keep rate-based control path if browser blocks the jump.
                }
              }
            }
          }
        }
      }

      syncFilteredError = (syncFilteredError * 0.78) + (error * 0.22);
      if (Math.abs(error) > LIVE_DEAD_BAND) {
        syncIntegralError += error * dt;
        syncIntegralError = Math.max(-LIVE_RATE_INTEGRAL_CLAMP, Math.min(LIVE_RATE_INTEGRAL_CLAMP, syncIntegralError));
      } else {
        syncIntegralError *= 0.85;
      }

      let rateMin = LIVE_RATE_MIN;
      let rateMax = LIVE_RATE_MAX;
      if (absError > 2.5) {
        rateMin = LIVE_RATE_MIN_VERY_LARGE;
        rateMax = LIVE_RATE_MAX_VERY_LARGE;
      } else if (absError > 1.0) {
        rateMin = LIVE_RATE_MIN_LARGE;
        rateMax = LIVE_RATE_MAX_LARGE;
      }

      let targetRate = 1 - ((LIVE_RATE_P * syncFilteredError) + (LIVE_RATE_I * syncIntegralError));
      targetRate = Math.max(rateMin, Math.min(rateMax, targetRate));

      if (Date.now() < manualNudgeUntilMs) {
        if (manualNudgeDirection > 0) {
          targetRate = Math.max(targetRate, 1.12);
        } else if (manualNudgeDirection < 0) {
          targetRate = Math.min(targetRate, 0.88);
        }
      } else {
        manualNudgeDirection = 0;
      }

      const currentRate = Number.isFinite(media.playbackRate) ? media.playbackRate : 1.0;
      const nextRate = currentRate + ((targetRate - currentRate) * LIVE_RATE_SLEW);
      media.playbackRate = Math.max(0.5, Math.min(4.0, nextRate));
      syncInfo.textContent = 'Sync err: ' + error.toFixed(3) + 's'
        + (Number.isFinite(sourceDrift) ? ' (src ' + sourceDrift.toFixed(3) + 's)' : '')
        + (currentIsLiveStream ? ' (timing:video)' : '')
        + ' | rate ' + media.playbackRate.toFixed(3)
        + (currentIsLiveStream && LIVE_USE_VIDEO_HOLD_CATCHUP ? (liveVideoHoldActive ? ' | hold:on' : ' | hold:off') : '');
    }

    function startSyncLoop(sid) {
      clearSyncTimer();
      if (window.EventSource) {
        syncSource = new EventSource('./session/events?sid=' + encodeURIComponent(sid));
        syncSource.addEventListener('clock', function (event) {
          if (!sid || sid !== activeSessionId) return;
          try {
            const data = JSON.parse(event.data);
            applySyncCorrection(data);
            if (currentIsLiveStream && pendingAudioStart) {
              maybeStartPendingLiveAudio().catch(function () {});
            }
          } catch (_) {}
        });
        syncSource.addEventListener('close', function () {
          if (syncSource) {
            syncSource.close();
            syncSource = null;
          }
        });
        syncSource.onerror = function () {
          // Browser auto-reconnect handles transient issues.
        };
        return;
      }

      // Fallback for older browsers without EventSource.
      syncTimer = setInterval(async function () {
        if (!sid || sid !== activeSessionId) return;
        try {
          const res = await fetch('./session/clock?sid=' + encodeURIComponent(sid) + '&t=' + Date.now(), { cache: 'no-store' });
          if (!res.ok) return;
          const data = await res.json();
          applySyncCorrection(data);
          if (currentIsLiveStream && pendingAudioStart) {
            maybeStartPendingLiveAudio().catch(function () {});
          }
        } catch (_) {}
      }, 800);
    }

    async function attemptAudioPlay() {
      const media = currentIsLiveStream ? getLiveTimingMedia() : audio;
      try {
        await media.play();
        syncInfo.textContent = hasVideoFrame ? 'Sync: running' : 'Sync: audio running, waiting for video frame...';
        isPaused = false;
        updatePlayPauseUi();
        updateLiveStartAudioButton();
        refreshSeekUi();
        return true;
      } catch (_) {
        syncInfo.textContent = 'Sync: audio blocked by browser autoplay. Press Play in the overlay controls.';
        isPaused = true;
        updatePlayPauseUi();
        updateLiveStartAudioButton();
        return false;
      }
    }

    async function pauseBoth() {
      isPaused = true;
      pendingAudioStart = false;
      liveStartupWaitUntilMs = 0;
      liveStartupSeekApplied = false;
      syncFilteredError = 0;
      syncIntegralError = 0;
      lastSyncSampleAtMs = 0;
      lastLiveBufferedCatchupAtMs = 0;
      lastLiveEdgeSnapAtMs = 0;
      lastVideoRawClock = NaN;
      lastAudioRawClock = NaN;
      liveAudioOriginRawClock = NaN;
      liveAudioPlayIssuedAtMs = 0;
      liveAwaitingFirstPlaying = false;
      liveStartupPlayDelayAdjusted = false;
      liveFrameLoadCount = 0;
      liveFirstFrameLoadAtMs = 0;
      liveLastFrameLoadAtMs = 0;
      livePipelineGapEstimate = 0;
      liveVideoHoldActive = false;
      liveVideoHoldUntilMs = 0;
      clearLiveVideoHoldTimer();
      liveAudioHoldActive = false;
      clearLiveAudioHoldTimer();
      liveHoldCooldownUntilMs = 0;
      lastLiveHardSyncAtMs = 0;
      const safeAudioPos = mediaBaseTime + (Number.isFinite(audio.currentTime) ? audio.currentTime : 0);
      pausePositionSeconds = Math.max(
        0,
        safeAudioPos,
        mediaBaseTime + (Number.isFinite(lastPresentedVideoClock) ? lastPresentedVideoClock : (Number(lastVideoClock) || 0))
      );
      pausedFrameDataUrl = captureFrameDataUrl();
      audio.pause();
      audio.playbackRate = 1.0;
      if (currentIsLiveStream) {
        const media = getLiveTimingMedia();
        media.pause();
        media.playbackRate = 1.0;
      }
      suppressStreamError = true;
      if (currentVideoRenderer === 'webcodecs_h264') {
        stopWebCodecsVideo(false);
        stream.src = '';
        stream.style.display = 'none';
        streamCanvas.style.display = 'block';
      } else if (pausedFrameDataUrl) {
        stream.src = pausedFrameDataUrl;
        stream.style.display = 'block';
        streamCanvas.style.display = 'none';
      } else {
        stream.src = '';
      }
      updatePlayPauseUi();
      updateLiveStartAudioButton();
      refreshSeekUi();
      showPlayerControls();
      hideLoadingSpinner();
      statusEl.style.display = 'none';
      showOverlay('â–¶', true, true);
      savePlaybackState(true, 'pause');
    }

    async function playBoth() {
      if (!activeSessionId) return;
      isPaused = false;
      const startFrom = pausePositionSeconds > 0
        ? pausePositionSeconds
        : (mediaBaseTime + (Number.isFinite(audio.currentTime) ? audio.currentTime : 0));
      if (currentIsLiveStream) {
        liveTimingMode = 'master';
        hasVideoFrame = false;
        lastVideoClock = 0;
        setStreamFromTime(0);
        setAudioFromTime(0);
        pendingAudioStart = true;
        liveAudioRequestedAtMs = performance.now();
        liveAudioReadyAtMs = 0;
        liveFirstFrameAtMs = 0;
        liveStartupSeekApplied = false;
        liveStartupWaitUntilMs = performance.now() + Math.max(LIVE_STARTUP_BUFFER_WAIT_MS, LIVE_STARTUP_CLOCK_WAIT_MS);
        syncFilteredError = 0;
        syncIntegralError = 0;
        lastSyncSampleAtMs = 0;
        lastLiveAudioReloadAtMs = 0;
        lastLiveBufferedCatchupAtMs = 0;
        lastLiveEdgeSnapAtMs = 0;
        lastVideoRawClock = NaN;
        lastAudioRawClock = NaN;
        liveAudioOriginRawClock = NaN;
        liveAudioPlayIssuedAtMs = 0;
        liveAwaitingFirstPlaying = false;
        liveStartupPlayDelayAdjusted = false;
        liveFrameLoadCount = 0;
        liveFirstFrameLoadAtMs = 0;
        liveLastFrameLoadAtMs = 0;
        livePipelineGapEstimate = 0;
        liveVideoHoldActive = false;
        liveVideoHoldUntilMs = 0;
        clearLiveVideoHoldTimer();
        liveAudioHoldActive = false;
        clearLiveAudioHoldTimer();
        liveHoldCooldownUntilMs = 0;
        lastLiveHardSyncAtMs = 0;
        isPaused = false;
        updatePlayPauseUi();
        updateLiveStartAudioButton();
      } else {
        mediaBaseTime = startFrom;
        setAudioFromTime(startFrom);
        const audioStarted = await attemptAudioPlay();
        const videoStart = audioStarted
          ? Math.max(0, startFrom + (Number.isFinite(audio.currentTime) ? audio.currentTime : 0))
          : startFrom;
        setStreamFromTime(videoStart);
      }
      pausePositionSeconds = 0;
      pausedFrameDataUrl = '';
      updatePlayPauseUi();
      updateLiveStartAudioButton();
      refreshSeekUi();
      showPlayerControls();
      statusEl.style.display = 'none';
      showOverlay('â–¶', false, false);
      savePlaybackState(true, 'play');
    }

    form.addEventListener('submit', async function (event) {
      event.preventDefault();
      const url = input.value.trim();
      if (!url) return;
      const selectedSettings = getVideoSettings();
      currentVideoRenderer = selectedSettings.mode;
      currentMediaUrl = url;
      if (currentPlexMeta && currentPlexMeta.url !== url) {
        currentPlexMeta = null;
      }
      currentSessionMode = 'direct';
      const restoringThisSubmit = !!(restoreResumeState && restoreResumeState.url === url);
      const restoreStartPaused = !!(restoreResumeState && restoreResumeState.url === url && restoreResumeState.paused);
      const requestedStart = (!isLikelyLiveStream(url) && restoringThisSubmit)
        ? Math.max(0, Number(restoreResumeState.position) || 0)
        : 0;
      const forceStartPaused = restoreStartPaused || autoRestoreSubmitPending;
      autoRestoreSubmitPending = false;
      if (restoringThisSubmit && Number.isFinite(restoreResumeState.knownDuration) && restoreResumeState.knownDuration > 0) {
        knownDurationSeconds = restoreResumeState.knownDuration;
      }
      restoreResumeState = null;

      statusEl.style.display = 'none';
      showLoadingSpinner();
      stream.style.display = 'none';
      streamCanvas.style.display = 'none';
      stopWebCodecsVideo();
      syncInfo.textContent = 'Sync: preparing session...';
      clearSyncTimer();
      audio.pause();
      audio.src = '';
      liveMasterVideo.pause();
      liveMasterVideo.src = '';
      pendingAudioStart = true;
      liveAudioRequestedAtMs = 0;
      liveAudioReadyAtMs = 0;
      liveFirstFrameAtMs = 0;
      liveStartupSeekApplied = false;
      liveStartupWaitUntilMs = 0;
      activeSessionId = '';
      lastVideoClock = 0;
      lastSyncSampleAtMs = 0;
      hasVideoFrame = false;
      liveFirstFrameRetries = 0;
      clearLiveFirstFrameRetry();
      isPaused = false;
      currentIsLiveStream = isLikelyLiveStream(url);
      liveTimingMode = 'master';
      lastLargeDriftCorrectionAtMs = 0;
      lastLiveAudioReloadAtMs = 0;
      lastLiveBufferedCatchupAtMs = 0;
      lastLiveEdgeSnapAtMs = 0;
      lastVideoRawClock = NaN;
      lastAudioRawClock = NaN;
      liveAudioOriginRawClock = NaN;
      liveAudioPlayIssuedAtMs = 0;
      liveAwaitingFirstPlaying = false;
      liveStartupPlayDelayAdjusted = false;
      liveFrameLoadCount = 0;
      liveFirstFrameLoadAtMs = 0;
      liveLastFrameLoadAtMs = 0;
      livePipelineGapEstimate = 0;
      liveVideoHoldActive = false;
      liveVideoHoldUntilMs = 0;
      clearLiveVideoHoldTimer();
      liveAudioHoldActive = false;
      clearLiveAudioHoldTimer();
      liveHoldCooldownUntilMs = 0;
      lastLiveHardSyncAtMs = 0;
      mediaBaseTime = 0;
      pausePositionSeconds = 0;
      pausedFrameDataUrl = '';
      manualOffsetEdited = false;
      liveTunerActive = false;
      liveTunerApplied = false;
      liveTunerStartAt = Date.now();
      liveTunerSamples = [];
      syncFilteredError = 0;
      syncIntegralError = 0;
      previousSyncTarget = getTargetOffsetSeconds();
      manualNudgeDirection = 0;
      manualNudgeUntilMs = 0;
      seekRangeMax = 100;
      knownDurationSeconds = NaN;
      isSeeking = false;
      overlayPlayPauseBtn.disabled = true;
      updatePlayPauseUi();
      updateLiveStartAudioButton();
      refreshSeekUi();
      screenOverlay.classList.remove('show', 'fade');
      showPlayerControls();

      try {
        const startRes = await fetch('./session/start?url=' + encodeURIComponent(url), { cache: 'no-store' });
        if (!startRes.ok) throw new Error('session start failed');
        const data = await startRes.json();
        if (!data.sid) throw new Error('missing sid');
        if (Number.isFinite(Number(data.duration)) && Number(data.duration) > 0) {
          knownDurationSeconds = Number(data.duration);
        }
        const bufferedLiveMode = data.mode === 'buffered_live';
        currentSessionMode = String(data.mode || 'direct');

        activeSessionId = data.sid;
        if (bufferedLiveMode) {
          currentIsLiveStream = false;
          liveDebugLog('session mode buffered_live -> using non-live playback path', { sid: activeSessionId });
        }
        mediaBaseTime = 0;
        if (currentIsLiveStream) {
          if (forceStartPaused) {
            freezeOnNextFrame = true;
            setStreamFromTime(0);
            setAudioFromTime(0);
            pendingAudioStart = false;
            isPaused = true;
            pausePositionSeconds = 0;
            updatePlayPauseUi();
            syncInfo.textContent = 'Sync: paused (press Play)';
          } else {
            setStreamFromTime(0);
            setAudioFromTime(0);
            pendingAudioStart = true;
            liveAudioRequestedAtMs = performance.now();
            liveAudioReadyAtMs = 0;
            liveFirstFrameAtMs = 0;
            liveStartupSeekApplied = false;
            liveStartupWaitUntilMs = performance.now() + Math.max(LIVE_STARTUP_BUFFER_WAIT_MS, LIVE_STARTUP_CLOCK_WAIT_MS);
            isPaused = false;
            updatePlayPauseUi();
            syncInfo.textContent = 'Sync: waiting for video frame...';
            scheduleLiveFirstFrameRetry();
          }
        } else {
          mediaBaseTime = requestedStart;
          if (forceStartPaused) {
            pendingAudioStart = false;
            freezeOnNextFrame = true;
            isPaused = true;
            pausePositionSeconds = requestedStart;
            updatePlayPauseUi();
          }
          setAudioFromTime(requestedStart);
          let audioStarted = false;
          if (!restoreStartPaused) {
            audioStarted = await attemptAudioPlay();
            pendingAudioStart = !audioStarted;
          }
          const videoStart = audioStarted
            ? Math.max(0, requestedStart + (Number.isFinite(audio.currentTime) ? audio.currentTime : 0))
            : requestedStart;
          setStreamFromTime(videoStart);
        }
        statusEl.style.display = 'none';
        startSyncLoop(activeSessionId);
        startBandwidthMonitorLoop(activeSessionId);
        overlayPlayPauseBtn.disabled = false;
        updatePlayPauseUi();
        updateLiveStartAudioButton();
        refreshSeekUi();
        showPlayerControls();
        savePlaybackState(true);
      } catch (_) {
        pendingAudioStart = false;
        hideLoadingSpinner();
        statusEl.textContent = 'Could not create playback session.';
        syncInfo.textContent = 'Sync: failed';
        overlayPlayPauseBtn.disabled = true;
        updateLiveStartAudioButton();
      }
    });

    stream.addEventListener('load', function () {
      if (currentVideoRenderer !== 'mjpeg') return;
      const frameNow = performance.now();
      markPresentedVideoFrame(lastVideoClock);
      noteRenderedFrame();
      liveDebugLog('stream load frame', {
        live: currentIsLiveStream,
        frameCount: liveFrameLoadCount + (currentIsLiveStream ? 1 : 0),
        pendingAudioStart,
      });
      if (currentIsLiveStream) {
        liveFrameLoadCount += 1;
        if (!liveFirstFrameLoadAtMs) {
          liveFirstFrameLoadAtMs = frameNow;
        }
        liveLastFrameLoadAtMs = frameNow;
      }
      hasVideoFrame = true;
      liveFirstFrameAtMs = frameNow;
      clearLiveFirstFrameRetry();
      liveFirstFrameRetries = 0;
      hideLoadingSpinner();
      statusEl.style.display = 'none';
      stream.style.display = 'block';
      if (freezeOnNextFrame) {
        freezeOnNextFrame = false;
        freezeCurrentVideoFrame();
        return;
      }
      updateLiveStartAudioButton();
      if (isPaused) {
        return;
      }
      if (pendingAudioStart) {
        if (currentIsLiveStream) {
          maybeStartPendingLiveAudio().catch(function () {});
        } else {
          pendingAudioStart = false;
          attemptAudioPlay();
        }
      }
      refreshSeekUi();
      savePlaybackState(false);
    });

    stream.addEventListener('error', function () {
      if (currentVideoRenderer !== 'mjpeg') return;
      liveDebugLog('stream error', {
        suppressStreamError,
        currentIsLiveStream,
        hasVideoFrame,
        activeSessionId,
      });
      if (suppressStreamError) {
        suppressStreamError = false;
        return;
      }
      if (currentIsLiveStream) {
        if (!hasVideoFrame) {
          syncInfo.textContent = 'Sync: first video frame failed, retrying...';
          scheduleLiveFirstFrameRetry();
        } else {
          syncInfo.textContent = 'Sync: live video stalled';
        }
        return;
      }
      stream.style.display = 'none';
      hideLoadingSpinner();
      statusEl.style.display = 'block';
      statusEl.textContent = 'Could not start stream. Check URL/server/codec support.';
      pendingAudioStart = false;
      clearSyncTimer();
      audio.pause();
      audio.playbackRate = 1.0;
      liveMasterVideo.pause();
      liveMasterVideo.playbackRate = 1.0;
      syncInfo.textContent = 'Sync: stream error';
      overlayPlayPauseBtn.disabled = true;
      updatePlayPauseUi();
      savePlaybackState(true, 'seek');
    });

    audio.addEventListener('canplay', function () {
      liveDebugLog('audio canplay', {
        currentIsLiveStream,
        pendingAudioStart,
        readyState: audio.readyState,
      });
      if (currentIsLiveStream && !liveAudioReadyAtMs) {
        liveAudioReadyAtMs = performance.now();
      }
      if (pendingAudioStart) {
        if (currentIsLiveStream) {
          maybeStartPendingLiveAudio().catch(function () {});
          return;
        }
        pendingAudioStart = false;
        attemptAudioPlay();
      }
    });

    liveMasterVideo.addEventListener('canplay', function () {
      if (!currentIsLiveStream) return;
      liveDebugLog('liveMaster canplay', {
        pendingAudioStart,
        readyState: liveMasterVideo.readyState,
      });
      if (!liveAudioReadyAtMs) {
        liveAudioReadyAtMs = performance.now();
      }
      if (pendingAudioStart) {
        maybeStartPendingLiveAudio().catch(function () {});
      }
    });

    audio.addEventListener('progress', function () {
      if (!currentIsLiveStream || !pendingAudioStart) return;
      maybeStartPendingLiveAudio().catch(function () {});
    });

    liveMasterVideo.addEventListener('progress', function () {
      if (!currentIsLiveStream || !pendingAudioStart) return;
      maybeStartPendingLiveAudio().catch(function () {});
    });

    audio.addEventListener('play', function () {
      isPaused = false;
      updatePlayPauseUi();
      updateLiveStartAudioButton();
      hidePlayerControlsSoon(1800);
    });

    liveMasterVideo.addEventListener('play', function () {
      if (!currentIsLiveStream) return;
      liveDebugLog('liveMaster play', {
        currentTime: liveMasterVideo.currentTime,
      });
      isPaused = false;
      updatePlayPauseUi();
      updateLiveStartAudioButton();
      hidePlayerControlsSoon(1800);
    });

    function handleLiveFirstPlaying(media) {
      if (!currentIsLiveStream || !liveAwaitingFirstPlaying || liveStartupPlayDelayAdjusted) return;
      const playDelay = liveAudioPlayIssuedAtMs ? Math.max(0, (performance.now() - liveAudioPlayIssuedAtMs) / 1000) : 0;
      liveAwaitingFirstPlaying = false;
      liveStartupPlayDelayAdjusted = true;
      if (playDelay < LIVE_START_DELAY_SEEK_MIN) return;
      const bufferedEnd = getBufferedEndSeconds();
      if (!Number.isFinite(bufferedEnd)) return;
      const latestSafe = Math.max(0, bufferedEnd - LIVE_STARTUP_BUFFER_SLACK);
      const availableAdvance = latestSafe - media.currentTime;
      if (availableAdvance <= 0.08) return;
      const step = Math.max(0, Math.min(LIVE_START_DELAY_SEEK_MAX, playDelay, availableAdvance));
      if (step <= 0.08) return;
      try {
        media.currentTime = Math.max(0, media.currentTime + step);
        syncFilteredError = 0;
        syncIntegralError = 0;
        syncInfo.textContent = 'Sync: play-start catch-up +' + step.toFixed(2) + 's';
      } catch (_) {}
    }

    audio.addEventListener('playing', function () {
      handleLiveFirstPlaying(audio);
    });

    liveMasterVideo.addEventListener('playing', function () {
      if (!currentIsLiveStream) return;
      handleLiveFirstPlaying(liveMasterVideo);
    });

    audio.addEventListener('pause', function () {
      if (pendingAudioStart) return;
      isPaused = true;
      updatePlayPauseUi();
      updateLiveStartAudioButton();
      showPlayerControls();
    });

    liveMasterVideo.addEventListener('pause', function () {
      if (!currentIsLiveStream || pendingAudioStart) return;
      isPaused = true;
      updatePlayPauseUi();
      updateLiveStartAudioButton();
      showPlayerControls();
    });

    audio.addEventListener('ended', function () {
      isPaused = true;
      updatePlayPauseUi();
      updateLiveStartAudioButton();
      showPlayerControls();
      savePlaybackState(true, 'ended');
    });

    audio.addEventListener('error', function () {
      liveDebugLog('audio error', {
        currentIsLiveStream,
        hasVideoFrame,
        activeSessionId,
      });
      if (currentIsLiveStream) {
        // Live audio is driven by hidden video timing media; ignore visible audio element errors.
        return;
      }
      if (currentIsLiveStream && activeSessionId) {
        if (!hasVideoFrame) {
          syncInfo.textContent = 'Sync: waiting for video frame...';
          return;
        }
        const now = Date.now();
        const cooldownPassed = (now - lastLiveAudioReloadAtMs) >= LIVE_AUDIO_RELOAD_COOLDOWN_MS;
        if (!isPaused && cooldownPassed) {
          lastLiveAudioReloadAtMs = now;
          pendingAudioStart = true;
          liveAudioRequestedAtMs = performance.now();
          liveAudioReadyAtMs = 0;
          liveStartupSeekApplied = true;
          liveStartupWaitUntilMs = performance.now();
          liveAudioPlayIssuedAtMs = 0;
          liveAwaitingFirstPlaying = false;
          liveStartupPlayDelayAdjusted = false;
          setAudioFromTime(0);
          syncInfo.textContent = 'Sync: recovering live audio...';
          return;
        }
        syncInfo.textContent = 'Sync: live audio hiccup';
        return;
      }
      syncInfo.textContent = 'Sync: audio stream error';
      overlayPlayPauseBtn.disabled = true;
      updatePlayPauseUi();
      updateLiveStartAudioButton();
      savePlaybackState(true, 'stop');
    });

    liveMasterVideo.addEventListener('error', function () {
      if (!currentIsLiveStream) return;
      liveDebugLog('liveMaster error', {
        hasVideoFrame,
        activeSessionId,
      });
      if (!activeSessionId) {
        // Ignore stale errors during teardown/startup before session is active.
        return;
      }
      if (activeSessionId) {
        const now = Date.now();
        const cooldownPassed = (now - lastLiveAudioReloadAtMs) >= LIVE_AUDIO_RELOAD_COOLDOWN_MS;
        if (!isPaused && cooldownPassed) {
          lastLiveAudioReloadAtMs = now;
          pendingAudioStart = true;
          liveAudioRequestedAtMs = performance.now();
          liveAudioReadyAtMs = 0;
          liveStartupSeekApplied = true;
          liveStartupWaitUntilMs = performance.now();
          liveAudioPlayIssuedAtMs = 0;
          liveAwaitingFirstPlaying = false;
          liveStartupPlayDelayAdjusted = false;
          setAudioFromTime(0);
          syncInfo.textContent = 'Sync: recovering live audio...';
          return;
        }
        syncInfo.textContent = 'Sync: live audio hiccup';
        return;
      }
      syncInfo.textContent = 'Sync: audio stream error';
      overlayPlayPauseBtn.disabled = true;
      updatePlayPauseUi();
      updateLiveStartAudioButton();
      savePlaybackState(true);
    });

    overlayPlayPauseBtn.addEventListener('click', function (event) {
      event.stopPropagation();
      if (isPaused) {
        playBoth();
        return;
      }
      pauseBoth();
    });

    screenOverlay.addEventListener('click', function (event) {
      event.preventDefault();
      event.stopPropagation();
      if (!isPaused || !activeSessionId) return;
      playBoth();
    });

    fullWidthBtn.addEventListener('click', function (event) {
      event.stopPropagation();
      toggleFullWidthMode();
    });

    muteBtn.addEventListener('click', function (event) {
      event.stopPropagation();
      setMuted(!audio.muted);
    });

    playerControls.addEventListener('pointerdown', function (event) {
      event.stopPropagation();
    });

    screen.addEventListener('mouseenter', showPlayerControls);
    screen.addEventListener('mousemove', showPlayerControls);
    screen.addEventListener('dblclick', function (event) {
      if (event.target && event.target.closest('#playerControls')) return;
      event.preventDefault();
      toggleFullWidthMode();
    });
    screen.addEventListener('mouseleave', function () {
      hidePlayerControlsSoon(900);
    });
    screen.addEventListener('pointerdown', function (event) {
      if (event.pointerType === 'touch') {
        const nowMs = Date.now();
        const dx = (event.clientX || 0) - lastMediaTapX;
        const dy = (event.clientY || 0) - lastMediaTapY;
        const closeTap = (dx * dx + dy * dy) <= (28 * 28);
        if (nowMs - lastMediaTapAtMs < 340 && closeTap) {
          event.preventDefault();
          lastMediaTapAtMs = 0;
          toggleFullWidthMode();
          return;
        }
        lastMediaTapAtMs = nowMs;
        lastMediaTapX = event.clientX || 0;
        lastMediaTapY = event.clientY || 0;
        showPlayerControls();
      }
    });

    seekBar.addEventListener('pointerdown', function (event) {
      event.stopPropagation();
      isSeeking = true;
      showPlayerControls();
    });

    seekBar.addEventListener('input', function () {
      if (seekBar.disabled) return;
      isSeeking = true;
      const duration = Number.isFinite(audio.duration) ? audio.duration : NaN;
      const effectiveDuration = (Number.isFinite(knownDurationSeconds) && knownDurationSeconds > 0)
        ? knownDurationSeconds
        : duration;
      const next = Number(seekBar.value);
      const shown = Number.isFinite(effectiveDuration) && effectiveDuration > 0 ? effectiveDuration : NaN;
      timeLabel.textContent = formatClock(next) + ' / ' + formatClock(shown);
      showPlayerControls();
    });

    seekBar.addEventListener('change', async function () {
      if (seekBar.disabled || !activeSessionId) return;
      const target = Math.max(0, Number(seekBar.value) || 0);
      isSeeking = false;
      const wasPaused = isPaused;
      suppressStreamError = true;
      lastVideoClock = 0;
      hasVideoFrame = false;
      mediaBaseTime = target;
      // Force-close current video stream before reopening at the seek target.
      stream.src = '';
      stopWebCodecsVideo();
      setAudioFromTime(target);
      if (wasPaused) {
        if (!currentIsLiveStream) {
          freezeOnNextFrame = true;
          setStreamFromTime(target);
        }
        pausePositionSeconds = target;
        audio.pause();
      } else {
        const audioStarted = await attemptAudioPlay();
        if (!currentIsLiveStream) {
          const videoStart = audioStarted
            ? Math.max(0, target + (Number.isFinite(audio.currentTime) ? audio.currentTime : 0))
            : target;
          setStreamFromTime(videoStart);
        } else {
          setStreamFromTime(0);
        }
      }
      refreshSeekUi();
      showPlayerControls();
      savePlaybackState(true);
    });

    seekBar.addEventListener('pointerup', function () {
      isSeeking = false;
    });

    window.addEventListener('keydown', function (event) {
      if (event.key === 'Escape' && channelsModal.classList.contains('show')) {
        closeChannelsModal();
        return;
      }
      if (event.key.toLowerCase() !== 'f' || event.ctrlKey || event.metaKey || event.altKey) return;
      const tag = (event.target && event.target.tagName) ? event.target.tagName.toLowerCase() : '';
      if (tag === 'input' || tag === 'textarea' || tag === 'select' || (event.target && event.target.isContentEditable)) {
        return;
      }
      event.preventDefault();
      toggleFullWidthMode();
    });

    channelsBtn.addEventListener('click', function () {
      openChannelsModal();
    });

    channelsCloseBtn.addEventListener('click', function () {
      closeChannelsModal();
    });

    channelsModal.addEventListener('click', function (event) {
      if (event.target === channelsModal) {
        closeChannelsModal();
      }
    });

    channelsSearch.addEventListener('input', function () {
      renderChannelsList(filterChannels(channelsSearch.value));
    });

    for (const modeInput of playerModeInputs) {
      modeInput.addEventListener('change', function () {
        syncVideoSettingsInputs();
        saveVideoSettings();
      });
    }

    qualityInput.addEventListener('input', function () {
      syncVideoSettingsInputs();
      saveVideoSettings();
    });

    h264QualityInput.addEventListener('input', function () {
      syncVideoSettingsInputs();
      saveVideoSettings();
    });

    applyVideoSettingsBtn.addEventListener('click', function () {
      applyCurrentVideoSettings();
    });

    videoSettingsToggleBtn.addEventListener('click', function () {
      const collapsed = !videoSettingsPanel.classList.contains('collapsed');
      setVideoSettingsCollapsed(collapsed);
    });

    audio.addEventListener('timeupdate', refreshSeekUi);
    audio.addEventListener('timeupdate', function () {
      savePlaybackState(false);
    });
    audio.addEventListener('loadedmetadata', refreshSeekUi);
    audio.addEventListener('durationchange', refreshSeekUi);

    plexSearch.addEventListener('input', function () {
      const q = plexSearch.value.trim();
      const requestSeq = ++plexSearchRequestSeq;
      if (plexSearchTimer) {
        clearTimeout(plexSearchTimer);
        plexSearchTimer = null;
      }
      if (q.length < 2) {
        hidePlexSuggestions();
        hidePlexBrowser();
        return;
      }
      plexSearchTimer = setTimeout(async function () {
        try {
          const res = await fetch('./plex/search?q=' + encodeURIComponent(q), { cache: 'no-store' });
          if (requestSeq !== plexSearchRequestSeq) return;
          if (!res.ok) return;
          const data = await res.json();
          if (requestSeq !== plexSearchRequestSeq) return;
          hidePlexBrowser();
          renderPlexSuggestions(data.results || []);
        } catch (_) {}
      }, 160);
    });

    document.addEventListener('click', function (event) {
      if (event.target === plexSearch || plexSuggest.contains(event.target) || plexBrowser.contains(event.target)) return;
      hidePlexSuggestions();
      hidePlexBrowser();
    });

    setInterval(function () {
      savePlaybackState(false);
    }, 3000);

    setInterval(function () {
      void syncPlexHistoryPull(false);
    }, PLEX_SYNC_PULL_INTERVAL_MS);

    window.addEventListener('beforeunload', function () {
      savePlaybackState(true);
    });

    restoreVideoSettings();
    restoreVideoSettingsCollapsed();
    syncVideoSettingsInputs();
    renderBandwidthMonitor(null);
    renderFpsMonitor();
    renderOffsetValue();
    void loadPlexHistory();
    void syncPlexHistoryPull(true);
    refreshSeekUi();
    updatePlayPauseUi();
    setFullWidthMode(document.body.classList.contains('full-width'));
    setMuted(false);
    updateLiveStartAudioButton();
    showPlayerControls();
    // Keep optional URL prefill from address bar, but never auto-start playback.
    applyAddressBarUrl();
  </script>
</body>
</html>
